<div align="center">
  <h3> Universidad Peruana de Ciencias Aplicadas </h3>

<img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png" alt="Imagen centrada" width="200"/>

  <h5> Ingeniería de Software </h5>

  <h5> Diseño de Experimentos de Ingeniería de Software </h5>

  <h5> NRC: 14651 </h5>

  <h5> Docente: Juan Carlos Tinoco Licas </h5>

  <h5> Informe del Trabajo Final </h5>

  <h5> Startup: Cowders </h5>

  <h5> Producto: Moobile </h5>
</div>

<div align="center">
    <h3>Integrantes:</h3>
</div>

<div>
     <table align="center">
        <tr>
            <th style="text-align:center;">Apellidos y nombres</th>
            <th style="text-align:center;">Código</th>
        </tr>
        <tr>
            <td>Bravo Gavilano, Jorge Rafael</td>
            <td>U202212535</td>
        </tr>
        <tr>
            <td>Gonzalez Custodio, Carlos Alberto</td>
            <td>U202020230</td>
        </tr>
        <tr>
            <td>Martinez Ramos, Bryan Felix</td>
            <td>U202316246</td>
        </tr>
        <tr>
            <td>Roque Tello, Jack Eddie</td>
            <td>U20221C448</td>
        </tr>
        <tr>
            <td>Silva Morales, Renzo Cesar</td>
            <td>U20221C362</td>
        </tr>
    </table>
</div>

<div align="center">
<h5> Setiembre 2025 </h5>
</div>

## Registro de versiones del informe

|**Versión**|**Fecha**|**Autor**|**Descripción de modificación**|
| :-: | :-: | :-: | :-: |
|1\.0|10/09/2025|Moobile|Redacción de los Capítulos I: Introducción, II: Requirements Elicitation & Analysis, III: Requirements Specification, IV: Product Design y V: Product Implementation|

# Project Report Collaboration Insights

# Contenido

## Tabla de contenidos

- [Registro de versiones del informe](#registro-de-versiones-del-informe)
- [Project Report Collaboration Insights](#project-report-collaboration-insights)
- [Contenido](#contenido)
  - [Tabla de contenidos](#tabla-de-contenidos)
- [Student Outcome](#student-outcome)
- [Part I: As-Is Software Project](#part-i-as-is-software-project)
  - [Capítulo I: Introducción](#capítulo-i-introducción)
    - [1.1. Startup Profile](#11-startup-profile)
      - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
      - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
    - [1.2. Solution Profile](#12-solution-profile)
      - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
      - [1.2.2. Lean UX Process](#122-lean-ux-process)
        - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
        - [1.2.2.1. Lean UX Assumptions](#1221-lean-ux-assumptions)
        - [1.2.2.1. Lean UX Hypothesis Statements](#1221-lean-ux-hypothesis-statements)
        - [1.2.2.1. Lean UX Canvas](#1221-lean-ux-canvas)
    - [1.3. Segmentos objetivo](#13-segmentos-objetivo)
  - [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
    - [2.1. Competidores](#21-competidores)
      - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
      - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
    - [2.2. Entrevistas](#22-entrevistas)
      - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
      - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
      - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
    - [2.3. Needfinding](#23-needfinding)
      - [2.3.1. User Personas](#231-user-personas)
      - [2.3.2. User Task Matrix](#232-user-task-matrix)
      - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
      - [2.3.4. Empathy Mapping](#234-empathy-mapping)
      - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
    - [2.4. Ubiquitous Language](#24-ubiquitous-language)
  - [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification)
    - [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
    - [3.2. User Stories](#32-user-stories)
    - [3.3. Product Backlog](#33-product-backlog)
    - [3.4. Impact Mapping](#34-impact-mapping)
  - [Capítulo IV: Product Design](#capítulo-iv-product-design)
    - [4.1. Style Guidelines](#41-style-guidelines)
      - [4.1.1. General Style Guidelines](#411-general-style-guidelines)
      - [4.1.2. Web Style Guidelines](#412-web-style-guidelines)
      - [4.1.3. Mobile Style Guidelines](#413-mobile-style-guidelines)
        - [4.1.3.1. iOS Mobile Style Guidelines](#4131-ios-mobile-style-guidelines)
        - [4.1.3.2. Android Mobile Style Guidelines](#4132-android-mobile-style-guidelines)
    - [4.2. Information Architecture](#42-information-architecture)
      - [4.2.1. Organization Systems](#421-organization-systems)
      - [4.2.2. Labeling Systems](#422-labeling-systems)
      - [4.2.3. SEO Tags and Meta Tags](#423-seo-tags-and-meta-tags)
      - [4.2.4. Searching Systems](#424-searching-systems)
      - [4.2.5. Navigation Systems](#425-navigation-systems)
    - [4.3. Landing Page UI Design](#43-landing-page-ui-design)
      - [4.3.1. Landing Page Wireframe](#431-landing-page-wireframe)
      - [4.3.2. Landing Page Mock-up](#432-landing-page-mock-up)
    - [4.4. Mobile Applications UX/UI Design](#44-mobile-applications-uxui-design)
      - [4.4.1. Mobile Applications Wireframes](#441-mobile-applications-wireframes)
      - [4.4.2. Mobile Applications Wireflow Diagrams](#442-mobile-applications-wireflow-diagrams)
      - [4.4.3. Mobile Applications Mock-ups](#443-mobile-applications-mock-ups)
      - [4.4.4. Mobile Applications User Flow Diagrams](#444-mobile-applications-user-flow-diagrams)
    - [4.5. Mobile Applications Prototyping](#45-mobile-applications-prototyping)
      - [4.5.1. Android Mobile Applications Prototyping](#451-android-mobile-applications-prototyping)
      - [4.5.2. iOS Mobile Applications Prototyping](#452-ios-mobile-applications-prototyping)
    - [4.6. Web Applications UX/UI Design](#46-web-applications-uxui-design)
      - [4.6.1. Web Applications Wireframes](#461-web-applications-wireframes)
      - [4.6.2. Web Applications Wireflow Diagrams](#462-web-applications-wireflow-diagrams)
      - [4.6.3. Web Applications Mock-ups](#463-web-applications-mock-ups)
      - [4.6.4. Web Applications User Flow Diagrams](#464-web-applications-user-flow-diagrams)
    - [4.7. Web Applications Prototyping](#47-web-applications-prototyping)
    - [4.8. Domain-Driven Software Architecture](#48-domain-driven-software-architecture)
      - [4.8.1. Software Architecture Context Diagram](#481-software-architecture-context-diagram)
      - [4.8.2. Software Architecture Container Diagrams](#482-software-architecture-container-diagrams)
      - [4.8.3. Software Architecture Components Diagrams](#483-software-architecture-components-diagrams)
    - [4.9. Software Object-Oriented Design](#49-software-object-oriented-design)
      - [4.9.1. Class Diagrams](#491-class-diagrams)
      - [4.9.2. Class Dictionary](#492-class-dictionary)
    - [4.10. Database Design](#410-database-design)
      - [4.10.1. Relational/Non-Relational Database Diagram](#4101-relationalnon-relational-database-diagram)
  - [Capítulo V: Product Implementation](#capítulo-v-product-implementation)
    - [5.1. Software Configuration Management](#51-software-configuration-management)
      - [5.1.1. Software Development Environment Configuration](#511-software-development-environment-configuration)
      - [5.1.2. Source Code Management](#512-source-code-management)
      - [5.1.3. Source Code Style Guide & Conventions](#513-source-code-style-guide--conventions)
      - [5.1.4. Software Deployment Configuration](#514-software-deployment-configuration)
    - [5.2. Product Implementation & Deployment](#52-product-implementation--deployment)
      - [5.2.1. Sprint Backlogs](#521-sprint-backlogs)
      - [5.2.2. Implemented Landing Page Evidence](#522-implemented-landing-page-evidence)
      - [5.2.3. Implemented Frontend-Web Application Evidence](#523-implemented-frontend-web-application-evidence)
      - [5.2.4. Acuerdo de Servicio - SaaS](#524-acuerdo-de-servicio---saas)
      - [5.2.5. Implemented Native-Mobile Application Evidence](#525-implemented-native-mobile-application-evidence)
      - [5.2.6. Implemented RESTful API and/or Serverless Backend Evidence](#526-implemented-restful-api-andor-serverless-backend-evidence)
      - [5.2.7. RESTful API documentation](#527-restful-api-documentation)
      - [5.2.8. Team Collaboration Insights](#528-team-collaboration-insights)
    - [5.3. Video About-the-Product](#53-video-about-the-product)
- [Part II: Verification, Validation & Pipeline](#part-ii-verification-validation--pipeline)
  - [Capítulo VI: Product Verification & Validation](#capítulo-vi-product-verification--validation)
    - [6.1. Testing Suites & Validation](#61-testing-suites--validation)
      - [6.1.1. Core Entities Unit Tests](#611-core-entities-unit-tests)
      - [6.1.2. Core Integration Tests](#612-core-integration-tests)
      - [6.1.3. Core Behavior-Driven Development](#613-core-behavior-driven-development)
      - [6.1.4. Core System Tests](#614-core-system-tests)
    - [6.2. Static testing & Verification](#62-static-testing--verification)
      - [6.2.1. Static Code Analysis](#621-static-code-analysis)
        - [6.2.1.1. Coding standard & Code conventions](#6211-coding-standard--code-conventions)
        - [6.2.1.2. Code Quality & Code Security](#6212-code-quality--code-security)
      - [6.2.2. Reviews](#622-reviews)
    - [6.3. Validation Interviews](#63-validation-interviews)
      - [6.3.1. Diseño de Entrevistas](#631-diseño-de-entrevistas)
      - [6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
      - [6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-según-heurísticas)
    - [6.4. Auditoría de Experiencias de Usuario](#64-auditoría-de-experiencias-de-usuario)
      - [6.4.1. Auditoría realizada](#641-auditoría-realizada)
        - [6.4.1.1. Información del grupo auditado](#6411-información-del-grupo-auditado)
        - [6.4.1.2. Cronograma de auditoría realizada](#6412-cronograma-de-auditoría-realizada)
        - [6.4.1.3. Contenido de auditoría realizada](#6413-contenido-de-auditoría-realizada)
      - [6.4.2. Auditoría recibida](#642-auditoría-recibida)
        - [6.4.2.1. Información del grupo auditor](#6421-información-del-grupo-auditor)
        - [6.4.2.2. Cronograma de auditoría recibida](#6422-cronograma-de-auditoría-recibida)
        - [6.4.2.3. Contenido de auditoría recibida](#6423-contenido-de-auditoría-recibida)
        - [6.4.2.4. Resumen de modificaciones para subsanar hallazgos](#6424-resumen-de-modificaciones-para-subsanar-hallazgos)
  - [Capítulo VII: DevOps Practices](#capítulo-vii-devops-practices)
    - [7.1. Continuous Integration](#71-continuous-integration)
      - [7.1.1. Tools and Practices](#711-tools-and-practices)
      - [7.1.2. Build & Test Suite Pipeline Components](#712-build--test-suite-pipeline-components)
    - [7.2. Continuous Delivery](#72-continuous-delivery)
      - [7.2.1. Tools and Practices](#721-tools-and-practices)
      - [7.2.2. Stages Deployment Pipeline Components](#722-stages-deployment-pipeline-components)
    - [7.3. Continuous deployment](#73-continuous-deployment)
      - [7.3.1. Tools and Practices](#731-tools-and-practices)
      - [7.3.2. Production Deployment Pipeline Components](#732-production-deployment-pipeline-components)
    - [7.4. Continuous Monitoring](#74-continuous-monitoring)
      - [7.4.1. Tools and Practices](#741-tools-and-practices)
      - [7.4.2. Monitoring Pipeline Components](#742-monitoring-pipeline-components)
      - [7.4.3. Alerting Pipeline Components](#743-alerting-pipeline-components)
      - [7.4.4. Notification Pipeline Components](#744-notification-pipeline-components)
- [Part III: Experiment-Driven Lifecycle](#part-iii-experiment-driven-lifecycle)
  - [Capítulo VIII: Experiment-Driven Development](#capítulo-viii-experiment-driven-development)
    - [8.1. Experiment Planning](#81-experiment-planning)
      - [8.1.1. As-Is Summary](#811-as-is-summary)
      - [8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims](#812-raw-material-assumptions-knowledge-gaps-ideas-claims)
      - [8.1.3. Experiment-Ready Questions](#813-experiment-ready-questions)
      - [8.1.4. Question Backlog](#814-question-backlog)
      - [8.1.5. Experiment Cards](#815-experiment-cards)
    - [8.2. Experiment Design](#82-experiment-design)
      - [8.2.1. Hypotheses](#821-hypotheses)
      - [8.2.2. Domain Business Metrics](#822-domain-business-metrics)
      - [8.2.3. Measures](#823-measures)
      - [8.2.4. Conditions](#824-conditions)
      - [8.2.5. Scale Calculations and Decisions](#825-scale-calculations-and-decisions)
      - [8.2.6. Methods Selection](#826-methods-selection)
      - [8.2.7. Data Analytics: Goals, KPIs and Metrics Selection](#827-data-analytics-goals-kpis-and-metrics-selection)
      - [8.2.8. Web and Mobile Tracking Plan](#828-web-and-mobile-tracking-plan)
    - [8.3. Experimentation](#83-experimentation)
      - [8.3.1. To-Be User Stories](#831-to-be-user-stories)
      - [8.3.2. To-Be Product Backlog](#832-to-be-product-backlog)
      - [8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle](#833-pipeline-supported-experiment-driven-to-be-software-platform-lifecycle)
        - [8.3.3.1. To-Be Sprint Backlogs](#8331-to-be-sprint-backlogs)
        - [8.3.3.2. Implemented To-Be Landing Page Evidence](#8332-implemented-to-be-landing-page-evidence)
        - [8.3.3.3. Implemented To-Be Frontend-Web Application Evidence](#8333-implemented-to-be-frontend-web-application-evidence)
        - [8.3.3.4. Implemented To-Be Native-Mobile Application Evidence](#8334-implemented-to-be-native-mobile-application-evidence)
        - [8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence](#8335-implemented-to-be-restful-api-andor-serverless-backend-evidence)
        - [8.3.3.6. Team Collaboration Insights](#8336-team-collaboration-insights)
      - [8.3.4. To-Be Validation Interviews](#834-to-be-validation-interviews)
        - [8.3.4.1. Diseño de Entrevistas](#8341-diseño-de-entrevistas)
        - [8.3.4.2. Registro de Entrevistas](#8342-registro-de-entrevistas)
    - [8.4. Experiment Aftermath & Analysis](#84-experiment-aftermath--analysis)
      - [8.4.1. Analysis and Interpretation of Results](#841-analysis-and-interpretation-of-results)
      - [8.4.2. Re-scored and Re-prioritized Question Backlog](#842-re-scored-and-re-prioritized-question-backlog)
    - [8.5. Continuous Learning](#85-continuous-learning)
      - [8.5.1. Shareback Session Artifacts: Learning Workflow](#851-shareback-session-artifacts-learning-workflow)
    - [8.6. To-Be Software Platform Pre-launch](#86-to-be-software-platform-pre-launch)
      - [8.6.1. About-the-Product Intro Video](#861-about-the-product-intro-video)

- [Conclusiones](#conclusiones)
  - [Conclusiones Y Recomendaciones](#conclusiones-y-recomendaciones)
  - [Video App Validation](#video-app-validation)
  - [Video About-the-Team](#video-about-the-team)

- [Bibliografía](#bibliografía)

- [Anexos](#anexos)

# Student Outcome

|**Criterio específico**|**Acciones realizadas**|**Conclusiones**|
| :-: | :-: | :-: |
| Reconoce responsabilidad ética y profesional en situaciones de ingeniería de software | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |
| Emite juicios informados considerando el impacto de las soluciones de ingeniería de software en contextos globales, económicos, ambientales y sociales | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |

----

# **Part I: As-Is Software Project**

# **Capítulo I: Introducción**

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup

### 1.1.2. Perfiles de integrantes del equipo

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.1. Lean UX Assumptions

#### 1.2.2.1. Lean UX Hypothesis Statements

#### 1.2.2.1. Lean UX Canvas

## 1.3. Segmentos objetivo

# **Capítulo II: Requirements Elicitation & Analysis**

## 2.1. Competidores

### 2.1.1. Análisis competitivo

### 2.1.2. Estrategias y tácticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. Análisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. As-is Scenario Mapping

## 2.4. Ubiquitous Language

# **Capítulo III: Requirements Specification**

## 3.1. To-Be Scenario Mapping

## 3.2. User Stories

## 3.3. Product Backlog

## 3.4. Impact Mapping

# **Capítulo IV: Product Design**

## 4.1. Style Guidelines

### 4.1.1. General Style Guidelines

### 4.1.2. Web Style Guidelines

### 4.1.3. Mobile Style Guidelines

#### 4.1.3.1. iOS Mobile Style Guidelines

#### 4.1.3.2. Android Mobile Style Guidelines

## 4.2. Information Architecture

### 4.2.1. Organization Systems

### 4.2.2. Labeling Systems

### 4.2.3. SEO Tags and Meta Tags

### 4.2.4. Searching Systems

### 4.2.5. Navigation Systems

## 4.3. Landing Page UI Design

### 4.3.1. Landing Page Wireframe

### 4.3.2. Landing Page Mock-up

## 4.4. Mobile Applications UX/UI Design

### 4.4.1. Mobile Applications Wireframes

### 4.4.2. Mobile Applications Wireflow Diagrams

### 4.4.3. Mobile Applications Mock-ups

### 4.4.4. Mobile Applications User Flow Diagrams

## 4.5. Mobile Applications Prototyping

### 4.5.1. Android Mobile Applications Prototyping

### 4.5.2. iOS Mobile Applications Prototyping

## 4.6. Web Applications UX/UI Design

### 4.6.1. Web Applications Wireframes

### 4.6.2. Web Applications Wireflow Diagrams

### 4.6.3. Web Applications Mock-ups

### 4.6.4. Web Applications User Flow Diagrams

## 4.7. Web Applications Prototyping

## 4.8. Domain-Driven Software Architecture

### 4.8.1. Software Architecture Context Diagram

### 4.8.2. Software Architecture Container Diagrams

### 4.8.3. Software Architecture Components Diagrams

## 4.9. Software Object-Oriented Design

### 4.9.1. Class Diagrams

### 4.9.2. Class Dictionary

## 4.10. Database Design

### 4.10.1. Relational/Non-Relational Database Diagram

# **Capítulo V: Product Implementation**

## 5.1. Software Configuration Management

### 5.1.1. Software Development Environment Configuration

### 5.1.2. Source Code Management

### 5.1.3. Source Code Style Guide & Conventions

### 5.1.4. Software Deployment Configuration

## 5.2. Product Implementation & Deployment

### 5.2.1. Sprint Backlogs

### 5.2.2. Implemented Landing Page Evidence

### 5.2.3. Implemented Frontend-Web Application Evidence

### 5.2.4. Acuerdo de Servicio - SaaS

### 5.2.5. Implemented Native-Mobile Application Evidence

### 5.2.6. Implemented RESTful API and/or Serverless Backend Evidence

### 5.2.7. RESTful API documentation

### 5.2.8. Team Collaboration Insights

## 5.3. Video About-the-Product

# **Part II: Verification, Validation & Pipeline**

# **Capítulo VI: Product Verification & Validation**

## 6.1. Testing Suites & Validation

### 6.1.1. Core Entities Unit Tests

### 6.1.2. Core Integration Tests

### 6.1.3. Core Behavior-Driven Development

### 6.1.4. Core System Tests

## 6.2. Static testing & Verification

### 6.2.1. Static Code Analysis

#### 6.2.1.1. Coding standard & Code conventions

#### 6.2.1.2. Code Quality & Code Security

### 6.2.2. Reviews

## 6.3. Validation Interviews

### 6.3.1. Diseño de Entrevistas

### 6.3.2. Registro de Entrevistas

### 6.3.3. Evaluaciones según heurísticas

## 6.4. Auditoría de Experiencias de Usuario

### 6.4.1. Auditoría realizada

#### 6.4.1.1. Información del grupo auditado

#### 6.4.1.2. Cronograma de auditoría realizada

#### 6.4.1.3. Contenido de auditoría realizada

### 6.4.2. Auditoría recibida

#### 6.4.2.1. Información del grupo auditor

#### 6.4.2.2. Cronograma de auditoría recibida

#### 6.4.2.3. Contenido de auditoría recibida

#### 6.4.2.4. Resumen de modificaciones para subsanar hallazgos

# **Capítulo VII: DevOps Practices**

## 7.1. Continuous Integration

Para el proyecto VacApp, desarrollado con React y TypeScript en el frontend y C#/.NET en el backend, se implementó un sistema de Integración Continua (CI) mediante GitHub Actions.
Este pipeline automatiza tareas clave como la validación del código, la verificación de tipos, la ejecución de pruebas y la preparación para el despliegue.
De esta manera, cada commit o pull request activa un flujo de validaciones automáticas que permiten detectar errores tempranamente, mantener la calidad del código y asegurar entregas más estables y confiables en los entornos de Azure App Service y Netlify.

### 7.1.1. Tools and Practices
Para la implementación de VacApp, desplegamos el frontend en Netlify y el backend en Azure App Service, garantizando un entorno escalable, seguro y de fácil mantenimiento.
Adoptamos el flujo Gitflow para la gestión de ramas en GitHub, junto con Conventional Commits para mantener una estructura clara en los mensajes de commit y SemVer para el versionamiento semántico.
Implementamos integración continua con GitHub Actions, que ejecuta automáticamente validaciones de código, análisis estático con ESLint, comprobación de tipos con TypeScript, y pruebas automatizadas tanto en el frontend como en el backend.

Para el frontend, empleamos pruebas unitarias y de integración usando React Testing Library junto con Vitest, lo que permite verificar la funcionalidad de los componentes y la interacción del usuario en entornos simulados.
En el backend, utilizamos NUnit como framework de testing principal, complementado con Selenium para realizar pruebas end-to-end sobre la interfaz de usuario, validando la integración entre el sistema web y los flujos de usuario reales.
Esta infraestructura de pruebas nos permite detectar errores de manera temprana y asegurar la estabilidad del producto antes de su despliegue.



| Característica     | NUnit | Selenium |
| ------------------ | ----- | -------- |
|                    |  <img width="150" alt="Image" src="https://github.com/user-attachments/assets/f58716a2-722e-4795-80ab-df5e720049cb" />  |    <img width="100" alt="Image" src="https://github.com/user-attachments/assets/061eb064-a4f3-43fe-beb5-870c6308c337" />   |
| Tipo | Framework de testing unitario para .NET| Framework de testing end-to-end para aplicaciones web |
| Lenguaje principal | C#  | Multilenguaje (C#, Java, Python, etc.)         |
| Enfoque            | Pruebas unitarias y de integración en el backend       | Pruebas funcionales simulando la interacción del usuario         |
| Ventajas Clave     | Estructura modular basada en fixtures, assertions y test cases parametrizados. Integración directa con Azure DevOps y GitHub Actions.      |  Ejecución de pruebas en navegadores reales, automatización de flujos completos y validación visual del frontend.        |
| Compatibilidad     | Integración con .NET y Azure Pipelines      | Soporte para múltiples navegadores y entornos CI/C         |
| Tipos de Prueba    | Unitarias, integración, regresión | End-to-End, UI, smoke y regresión visual|

<br>

**Workflow de Integración Continua**
Para asegurar la calidad y consistencia en el desarrollo de VacApp, todos los miembros del equipo siguen el siguiente flujo de trabajo:
	
  
  **1.	Desarrollo local:** Una vez finalizada una feature, el desarrollador ejecuta las pruebas automatizadas con NUnit y Selenium en su entorno local para garantizar la ausencia de errores o regresiones.

**2.	Pull Request:** Si las pruebas son exitosas, se crea una pull request hacia la rama develop, siguiendo el formato de commit definido por Conventional Commits e incluyendo el número de la PR (por ejemplo, #23).
  
  **3.	Pipeline automático:** Al subir la PR al repositorio remoto, GitHub Actions ejecuta automáticamente los pipelines configurados para:
	•	Validar el código con ESLint y TypeScript.
	•	Correr las suites de pruebas con NUnit para el backend.
	•	Ejecutar pruebas end-to-end con Selenium sobre entornos controlados.
  
  **4.	Revisión y pruebas de integración:** Una vez aprobada la PR, los cambios se integran a la rama release, donde se ejecutan pruebas de integración adicionales en un entorno similar a producción (Azure Test Environment).
	
  **5.	Despliegue a producción:** Si las pruebas son exitosas, se aprueba la pull request hacia main, lo que desencadena un despliegue automático:
	•	Frontend: en Netlify.
	•	Backend: en Azure App Service.
En caso de errores o fallas en los pipelines, el cambio se devuelve a la rama del desarrollador para su corrección antes de reiniciar el ciclo.

### 7.1.2. Build & Test Suite Pipeline Components

Este documento describe los Épicos (Epics) principales de la plataforma **Moobile-Platform**, organizados bajo el formato de Historias de Usuario para definir flujos de trabajo clave desde la perspectiva del usuario ganadero.

--

## Epic 01: Gestión de Establos

| Rol | Objetivo | Razón |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero gestionar los establos en la plataforma** | **Para mantener organizadas las instalaciones** donde se alojan los bovinos. |

<img width="886" height="551" alt="image" src="https://github.com/user-attachments/assets/3ee378e8-3f43-466d-8d6d-fa13cb040a08" />

--

## Epic 02: Gestión de Bovinos

| Rol | Objetivo | Razón |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero gestionar los bovinos registrados en mis establos** | **Para mantener un control organizado y actualizado** del ganado en la plataforma. |

<img width="886" height="555" alt="image" src="https://github.com/user-attachments/assets/7fc836ea-1302-4f0c-9985-28bbd83cb5a9" />

--

## Epic 03: Edición de Bovinos

| Rol | Objetivo | Razón |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero editar la información de los bovinos,** | **Para actualizar sus datos cuando sea necesario** (peso, edad, raza o estado reproductivo). |

<img width="886" height="565" alt="image" src="https://github.com/user-attachments/assets/504861c5-2bca-42e2-8449-7e1b9f424e26" />

--

## Epic 04: Gestión de Campañas

| Rol | Objetivo | Razón |
| :--- | :--- | :--- |
| **Como empresario ganadero,** | **Quiero gestionar campañas sanitarias y de mejoramiento** | **Para coordinar actividades a gran escala** (ej., vacunación, suplementación) y asegurar el cuidado óptimo. |

<img width="886" height="620" alt="image" src="https://github.com/user-attachments/assets/d7386044-8ab9-44b7-bde3-16bbc1a48164" />

--

## Epic 05: Gestión de Staff

| Rol | Objetivo | Razón |
| :--- | :--- | :--- |
| **Como empresario ganadero,** | **Quiero gestionar el personal que trabaja en mi operación ganadera** | **Para organizar eficientemente los recursos humanos** y asignar tareas. |

<img width="886" height="634" alt="image" src="https://github.com/user-attachments/assets/7c866db4-f04e-48c6-a965-06e0a2858013" />

## 7.2. Continuous Delivery

En este apartado se puede encontrar tres puntos principales a tomar en cuenta: La automatización de pruebas (pruebas unitarias, pruebas de integración y pruebas funcionales y de aceptación), el
entorno de pruebas automatizado y las pruebas de rendimiento y carga.

### 7.2.1. Tools and Practices

Para la implementación de VacApp, se emplearon distintas herramientas que cubren desde el análisis estático del código hasta las pruebas automatizadas y la integración continua. El objetivo principal fue garantizar la calidad, estabilidad y mantenibilidad del sistema a través de un proceso de desarrollo controlado y validado en múltiples niveles.

**NUnit:** Framework principal de pruebas unitarias para el backend desarrollado en C# y .NET. Permite validar la lógica de negocio definida en los distintos bounded contexts del dominio de VacApp mediante una convención de nomenclatura descriptiva, asegurando legibilidad y consistencia. Las pruebas de Core Entities Unit Tests cubren las funcionalidades derivadas de las 28 User Stories implementadas, mientras que las Core Integration Tests validan la interacción entre componentes, con 3 pruebas por bounded context y 2 para el módulo IAM (Identity and Access Management).

<img width="220" alt="Image" src="https://github.com/user-attachments/assets/3064c1c8-897d-42ec-a4ea-bbe9cba54b76" />

**Selenium:** Utilizado en los Core System Tests para realizar pruebas end-to-end sobre la interfaz del frontend desarrollado en React y TypeScript, simulando la interacción real de los usuarios con el sistema. Permite validar los flujos críticos del sistema, como autenticación, registro de ganado, gestión de vacunas y campañas, asegurando que la aplicación funcione correctamente en entornos reales.

<img width="100" alt="Image" src="https://github.com/user-attachments/assets/2ce9c224-5952-4554-849b-bcea88239d17" />

**Cucumber:** Implementado en la capa de Core Behavior-Driven Development (BDD) para la ejecución de Acceptance Tests. Las pruebas se redactan en lenguaje Gherkin, lo que facilita la comprensión tanto por parte del equipo técnico como de los stakeholders no técnicos. Estas pruebas aseguran que cada User Story (US) cumpla con los criterios de aceptación definidos, validando comportamientos esperados del sistema desde la perspectiva del usuario final.

<img width="400" alt="Image" src="https://github.com/user-attachments/assets/c40d7548-75c6-42a8-81dd-71921939313a" />

**GitHub Actions:** Sistema de integración y despliegue continuo (CI/CD) encargado de automatizar la ejecución de pruebas unitarias, de integración y end-to-end en cada pull request. Además, realiza validaciones de código con ESLint y análisis de tipado con TypeScript, garantizando la calidad del código antes de fusionar los cambios en la rama principal del proyecto.

<img width="170" height="132" alt="Image" src="https://github.com/user-attachments/assets/e98893cf-36ab-448e-907c-a7c3cfacf6bf" />

**ESLint y TypeScript:** Se utilizan de manera conjunta en el frontend para mantener un código limpio, consistente y seguro. ESLint aplica reglas personalizadas de estilo, seguridad y buenas prácticas en React, mientras que TypeScript ofrece comprobación estática de tipos, minimizando errores en tiempo de ejecución y mejorando la mantenibilidad a largo plazo.

<img height="100" alt="Image" src="https://github.com/user-attachments/assets/2bbde38e-6843-43b9-b311-345b040a3bf7" />

**Azure App Service:** Servicio en la nube de Microsoft Azure utilizado para desplegar y administrar el backend desarrollado en .NET. Ofrece integración directa con GitHub Actions, soporte para despliegues automatizados y escalabilidad bajo demanda. Permite realizar pruebas en entornos preconfigurados, gestionar logs y monitorear el rendimiento del sistema de manera continua.

<img width="200" alt="image" src="https://github.com/user-attachments/assets/e4b90ae3-e64f-4e85-968f-8ad3d5bfdc6f" />

**Netlify:** Plataforma utilizada para el despliegue del frontend desarrollado en React y TypeScript. Ofrece integración continua con GitHub, lo que permite realizar despliegues automáticos tras cada merge en la rama principal. Además, proporciona un entorno de hosting rápido, seguro y con soporte para HTTPS, control de versiones y previsualización de cambios antes del despliegue final.

<img width="200" alt="Image" src="https://github.com/user-attachments/assets/bd3f8e61-bc2b-4be1-8a8e-2500840f4e07" />

---

### 7.2.2. Stages Deployment Pipeline Components

A continuación, se describen las etapas del pipeline de despliegue implementado en el proyecto **VacApp**.  
Cada fase fue diseñada para garantizar una entrega continua, confiable y de alta calidad del software, asegurando la integración fluida entre el **frontend (React + TypeScript)** y el **backend (.NET + C#)**.

**1. Code Commit**
El proceso se inicia cuando un desarrollador realiza un commit en el repositorio de código.  
Se utiliza **Git** como sistema de control de versiones y **GitHub** como plataforma de alojamiento.  
Todos los commits siguen la convención de **Conventional Commits** para mantener mensajes claros, estructurados y compatibles con **SemVer** (versionado semántico).

**2. Linting y Verificación de Tipos**
En esta etapa se ejecutan herramientas de análisis estático del código en el **frontend**, utilizando **ESLint** para validar la calidad y estilo, y **TypeScript** para la comprobación estricta de tipos.  
Esta validación temprana asegura la robustez del código y previene errores antes de llegar a etapas posteriores del pipeline.

**3. Build**
El código del **frontend** se compila con **Vite** y **TypeScript**, generando los artefactos listos para despliegue en **Netlify**.  
Simultáneamente, el **backend** se compila en **.NET SDK**, verificando la integridad de dependencias, controladores, entidades y servicios.  
Esta fase asegura que no existan errores de compilación y que el sistema esté preparado para las pruebas automatizadas.

**4. Test Unitarios**
Se ejecutan las pruebas unitarias mediante **NUnit** para el backend, cubriendo las **Core Entities Unit Tests** y asegurando el correcto funcionamiento de la lógica de negocio individual.  
Cada prueba sigue una convención descriptiva (*Método_DadaCondición_DeberíaResultadoEsperado*) que mejora la mantenibilidad y claridad de los resultados.

**5. Test de Integración**
Durante esta etapa se ejecutan las **Core Integration Tests** con **NUnit**, validando la interacción entre los distintos **bounded contexts** del dominio y los módulos de infraestructura.  
Cada contexto incluye tres pruebas principales, además de dos pruebas específicas para el módulo **IAM (Identity and Access Management)**.

**6. Test End-to-End**
Las **Core System Tests** se ejecutan con **Selenium**, simulando la interacción real de los usuarios sobre la interfaz web desarrollada en **React**.  
Estas pruebas validan los flujos críticos como el inicio de sesión, la gestión de bovinos, vacunas y campañas, garantizando la correcta experiencia de usuario final.

**7. Acceptance Tests (BDD)**
En esta fase se ejecutan pruebas **Behavior-Driven Development (BDD)** con **Cucumber**, empleando el lenguaje **Gherkin** para validar las 28 **User Stories (US)** del sistema.  
Cada escenario describe comportamientos esperados desde la perspectiva del usuario, facilitando la validación del producto frente a los criterios de aceptación definidos.

**8. Staging Deployment**
Tras superar las fases de prueba, el sistema se despliega automáticamente en un entorno de **staging**:
- **Backend:** desplegado en **Azure App Service**, replicando el entorno productivo.  
- **Frontend:** desplegado en **Netlify**, permitiendo previsualizar la versión antes del lanzamiento final.  
En esta etapa se realizan pruebas adicionales de integración, rendimiento y conectividad entre servicios.

**9. Production Release**
Luego de la aprobación en *staging*, los cambios son fusionados en la rama `main`.  
El pipeline de **GitHub Actions** ejecuta el **despliegue automático a producción**, publicando:
- El **frontend** en **Netlify**.  
- El **backend** en **Azure App Service**.  
Este proceso asegura un flujo continuo y sin intervención manual, reduciendo tiempos de entrega y errores humanos.

**10. Monitoreo Post-Despliegue**
Una vez en producción, **VacApp** es monitoreada continuamente para verificar su rendimiento y estabilidad.  
El backend utiliza **Azure Monitor** y **Application Insights** para el registro estructurado, métricas de uso y detección temprana de errores.  
Asimismo, se supervisa la disponibilidad del frontend mediante herramientas integradas en **Netlify Analytics**, garantizando una respuesta rápida ante cualquier incidencia.

## 7.3. Continuous deployment

El despliegue continuo es una práctica fundamental en el desarrollo de software moderno, que automatiza la entrega de cambios al entorno de producción. En esta sección se describen las
herramientas y procesos implementados para asegurar un flujo de trabajo eficiente, permitiendo que el software sea desplegado de manera rápida, segura y consistente.

### 7.3.1. Tools and Practices

**GitHub Actions:**
Es el motor principal de automatización CI/CD en el proyecto VacApp.
Se configuraron flujos de trabajo que se ejecutan automáticamente ante cada push o pull request en el repositorio.
Estos pipelines realizan una serie de validaciones, incluyendo análisis estático de código con ESLint, verificación de tipos con TypeScript, ejecución de pruebas unitarias con NUnit, pruebas de integración en los distintos bounded contexts, y pruebas end-to-end con Selenium.
En caso de que todas las verificaciones sean exitosas, se procede al despliegue automático del backend en Azure App Service y del frontend en Netlify, garantizando una entrega continua, estable y confiable del sistema.

<img width="170" height="132" alt="Image" src="https://github.com/user-attachments/assets/e98893cf-36ab-448e-907c-a7c3cfacf6bf" />

**Azure App Service:**
Es la plataforma utilizada para el despliegue del backend de VacApp desarrollado en .NET.
Permite integrar directamente el flujo de despliegue con GitHub Actions, ofreciendo un entorno administrado con soporte para scaling, monitoreo de rendimiento y gestión de versiones.
Su infraestructura automatizada facilita el despliegue sin intervención manual, reduciendo el riesgo de errores y mejorando los tiempos de entrega a producción.

<img width="200" alt="image" src="https://github.com/user-attachments/assets/e4b90ae3-e64f-4e85-968f-8ad3d5bfdc6f" />

**Netlify:**
Es la plataforma utilizada para el despliegue del frontend de VacApp, desarrollado en React y TypeScript.
Netlify proporciona integración nativa con GitHub, lo que permite generar previews automáticos de cada rama y realizar el despliegue final al aprobar los cambios en la rama principal.
Además, ofrece soporte para HTTPS, control de versiones y optimización automática del contenido estático, garantizando alto rendimiento en el entorno productivo.

<img width="200" alt="Image" src="https://github.com/user-attachments/assets/bd3f8e61-bc2b-4be1-8a8e-2500840f4e07" />

**ESLint + Prettier:**
Herramientas integradas en el pipeline de CI/CD para garantizar la calidad, legibilidad y consistencia del código en el frontend.
ESLint aplica reglas personalizadas específicas para proyectos en TypeScript y React, detectando errores de estilo, malas prácticas y vulnerabilidades potenciales.
Por su parte, Prettier asegura un formato uniforme en todo el código, siguiendo los estándares definidos por el equipo de desarrollo, como el uso de comillas simples, indentación consistente y trailing commas.
En conjunto, estas herramientas ayudan a mantener un código limpio, profesional y coherente entre todos los miembros del equipo.

<img width="301" height="167" alt="Image" src="https://github.com/user-attachments/assets/50cf0805-3b56-47ce-9151-de76d32da20a" />

**Monitoreo y Validación Post-Despliegue:**
Tras cada despliegue, el sistema se supervisa mediante Azure Monitor y Application Insights para registrar el rendimiento, analizar métricas y detectar errores en tiempo real.
En el frontend, Netlify Analytics permite verificar la disponibilidad y el comportamiento del sitio, asegurando una experiencia estable para los usuarios finales.

### 7.3.2. Production Deployment Pipeline Components

**Despliegue en Azure y Netlify:**

- Azure: Utilizamos Azure para el despliegue del backend, ya que ofrece una plataforma robusta y escalable con integración directa con GitHub, despliegue continuo, soporte completo para variables de entorno y servicios gestionados como Azure App Service o Azure Functions. Además, permite configurar dominios personalizados, certificados SSL y opciones avanzadas de monitoreo y seguridad, todo sin necesidad de gestionar servidores directamente.

- Netlify: Utilizamos Netlify para el despliegue del frontend, ya que permite una configuración rápida mediante integración con Git, despliegue continuo con cada push, gestión sencilla de variables de entorno y entrega optimizada a través de su red CDN global. También proporciona HTTPS automático y funciones como redirecciones, formularios y prerenderizado, lo que facilita un entorno de producción moderno y eficiente.

**Pruebas Unitarias y de Integración:**

- Pruebas Continuas: Adoptamos un enfoque riguroso en la ejecución de pruebas automatizadas utilizando Cucumber para pruebas de aceptación basadas en criterios de negocio y Selenium para pruebas de interfaz de usuario. Para las pruebas unitarias y de integración del backend, utilizamos el ecosistema de pruebas de .NET con C#, lo que nos permite validar el comportamiento de los componentes clave antes de cada despliegue.
- Cobertura de Pruebas: Empleamos herramientas de cobertura específicas para .NET con el fin de asegurar que el código esté correctamente probado. Esto nos permite identificar posibles brechas en la lógica de negocio y mantener un alto estándar de calidad. El enfoque en pruebas automatizadas reduce riesgos y asegura un funcionamiento confiable en entornos de producción.

El proceso de despliegue en producción de la aplicación se gestiona mediante un pipeline automatizado que utiliza Azure como plataforma de alojamiento del backend. Este flujo permite implementar de manera continua y eficiente los cambios aprobados en la rama principal del repositorio, garantizando una integración fluida entre el código fuente, los servicios desplegados y los entornos de producción. En la siguiente imagen se puede observar cómo Azure se integra dentro del pipeline de despliegue para proporcionar un entorno de backend estable, seguro y escalable, facilitando la entrega continua de nuevas funcionalidades a los usuarios finales.

[![image.png](https://i.postimg.cc/jjT5N1q0/image.png)](https://postimg.cc/k2jqPftf)

Para asegurar la calidad del software y verificar que se cumplan los requisitos funcionales establecidos en el product backlog, se han utilizado pruebas automatizadas mediante Selenium. Estas pruebas reproducen la interacción del usuario con la aplicación y se alinean con las historias de usuario priorizadas durante el desarrollo. De esta manera, se valida que cada funcionalidad implementada cumpla con los criterios de aceptación definidos por el equipo de producto. La siguiente imagen muestra la ejecución de un conjunto de pruebas automatizadas en Selenium, centradas en validar los escenarios clave definidos por las historias de usuario, como parte del proceso de aseguramiento de calidad antes del despliegue.

[![image.png](https://i.postimg.cc/t4BqZ4cB/image.png)](https://postimg.cc/qNCVW44K)

El despliegue del frontend de la aplicación se realiza mediante la plataforma Netlify, que permite una entrega continua y automatizada de la interfaz de usuario hacia producción. Gracias a su integración directa con sistemas de control de versiones como Git, Netlify detecta automáticamente los cambios en la rama principal del repositorio y ejecuta los procesos de construcción y despliegue sin necesidad de intervención manual. Esta automatización garantiza que las nuevas características visuales y mejoras en la experiencia del usuario estén disponibles de forma inmediata. En la siguiente imagen se ilustra cómo Netlify gestiona el pipeline de despliegue del frontend, incluyendo la detección de cambios, la generación del build estático y su publicación en un entorno seguro, escalable y con soporte para HTTPS automático.

[![image.png](https://i.postimg.cc/tC72QSjy/image.png)](https://postimg.cc/7f8gSNhQ)

## 7.4. Continuous Monitoring

### 7.4.1. Tools and Practices

### 7.4.2. Monitoring Pipeline Components

### 7.4.3. Alerting Pipeline Components

### 7.4.4. Notification Pipeline Components

# **Part III: Experiment-Driven Lifecycle**

# **Capítulo VIII: Experiment-Driven Development**

## 8.1. Experiment Planning

### 8.1.1. As-Is Summary

### 8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims

### 8.1.3. Experiment-Ready Questions

### 8.1.4. Question Backlog

### 8.1.5. Experiment Cards

## 8.2. Experiment Design

### 8.2.1. Hypotheses

### 8.2.2. Domain Business Metrics

### 8.2.3. Measures

### 8.2.4. Conditions

### 8.2.5. Scale Calculations and Decisions

### 8.2.6. Methods Selection

### 8.2.7. Data Analytics: Goals, KPIs and Metrics Selection

### 8.2.8. Web and Mobile Tracking Plan

## 8.3. Experimentation

### 8.3.1. To-Be User Stories

### 8.3.2. To-Be Product Backlog

### 8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle

#### 8.3.3.1. To-Be Sprint Backlogs

#### 8.3.3.2. Implemented To-Be Landing Page Evidence

#### 8.3.3.3. Implemented To-Be Frontend-Web Application Evidence

#### 8.3.3.4. Implemented To-Be Native-Mobile Application Evidence

#### 8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence

#### 8.3.3.6. Team Collaboration Insights

### 8.3.4. To-Be Validation Interviews

#### 8.3.4.1. Diseño de Entrevistas

#### 8.3.4.2. Registro de Entrevistas

## 8.4. Experiment Aftermath & Analysis

### 8.4.1. Analysis and Interpretation of Results

### 8.4.2. Re-scored and Re-prioritized Question Backlog

## 8.5. Continuous Learning

### 8.5.1. Shareback Session Artifacts: Learning Workflow

## 8.6. To-Be Software Platform Pre-launch

### 8.6.1. About-the-Product Intro Video

----

# Conclusiones

## Conclusiones Y Recomendaciones

## Video App Validation

## Video About-the-Team

----

# Bibliografía

----

# Anexos
