<div align="center">
  <h3> Universidad Peruana de Ciencias Aplicadas </h3>

<img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png" alt="Imagen centrada" width="200"/>

  <h5> Ingenier√≠a de Software </h5>

  <h5> Dise√±o de Experimentos de Ingenier√≠a de Software </h5>

  <h5> NRC: 14651 </h5>

  <h5> Docente: Juan Carlos Tinoco Licas </h5>

  <h5> Informe del Trabajo Final </h5>

  <h5> Startup: Cowders </h5>

  <h5> Producto: Moobile </h5>
</div>

<div align="center">
    <h3>Integrantes:</h3>
</div>

<div>
     <table align="center">
        <tr>
            <th style="text-align:center;">Apellidos y nombres</th>
            <th style="text-align:center;">C√≥digo</th>
        </tr>
        <tr>
            <td>Bravo Gavilano, Jorge Rafael</td>
            <td>U202212535</td>
        </tr>
        <tr>
            <td>Gonzalez Custodio, Carlos Alberto</td>
            <td>U202020230</td>
        </tr>
        <tr>
            <td>Martinez Ramos, Bryan Felix</td>
            <td>U202316246</td>
        </tr>
        <tr>
            <td>Roque Tello, Jack Eddie</td>
            <td>U20221C448</td>
        </tr>
        <tr>
            <td>Silva Morales, Renzo Cesar</td>
            <td>U20221C362</td>
        </tr>
    </table>
</div>

<div align="center">
<h5> Setiembre 2025 </h5>
</div>

## Registro de versiones del informe

|**Versi√≥n**|**Fecha**|**Autor**|**Descripci√≥n de modificaci√≥n**|
| :-: | :-: | :-: | :-: |
|1\.0|10/09/2025|Moobile|Redacci√≥n de los Cap√≠tulos I: Introducci√≥n, II: Requirements Elicitation & Analysis, III: Requirements Specification, IV: Product Design y V: Product Implementation|

# Project Report Collaboration Insights

# Contenido

## Tabla de contenidos

- [Registro de versiones del informe](#registro-de-versiones-del-informe)
- [Project Report Collaboration Insights](#project-report-collaboration-insights)
- [Contenido](#contenido)
  - [Tabla de contenidos](#tabla-de-contenidos)
- [Student Outcome](#student-outcome)
- [Part I: As-Is Software Project](#part-i-as-is-software-project)
  - [Cap√≠tulo I: Introducci√≥n](#cap√≠tulo-i-introducci√≥n)
    - [1.1. Startup Profile](#11-startup-profile)
      - [1.1.1. Descripci√≥n de la Startup](#111-descripci√≥n-de-la-startup)
      - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
    - [1.2. Solution Profile](#12-solution-profile)
      - [1.2.1. Antecedentes y problem√°tica](#121-antecedentes-y-problem√°tica)
      - [1.2.2. Lean UX Process](#122-lean-ux-process)
        - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
        - [1.2.2.1. Lean UX Assumptions](#1221-lean-ux-assumptions)
        - [1.2.2.1. Lean UX Hypothesis Statements](#1221-lean-ux-hypothesis-statements)
        - [1.2.2.1. Lean UX Canvas](#1221-lean-ux-canvas)
    - [1.3. Segmentos objetivo](#13-segmentos-objetivo)
  - [Cap√≠tulo II: Requirements Elicitation & Analysis](#cap√≠tulo-ii-requirements-elicitation--analysis)
    - [2.1. Competidores](#21-competidores)
      - [2.1.1. An√°lisis competitivo](#211-an√°lisis-competitivo)
      - [2.1.2. Estrategias y t√°cticas frente a competidores](#212-estrategias-y-t√°cticas-frente-a-competidores)
    - [2.2. Entrevistas](#22-entrevistas)
      - [2.2.1. Dise√±o de entrevistas](#221-dise√±o-de-entrevistas)
      - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
      - [2.2.3. An√°lisis de entrevistas](#223-an√°lisis-de-entrevistas)
    - [2.3. Needfinding](#23-needfinding)
      - [2.3.1. User Personas](#231-user-personas)
      - [2.3.2. User Task Matrix](#232-user-task-matrix)
      - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
      - [2.3.4. Empathy Mapping](#234-empathy-mapping)
      - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
    - [2.4. Ubiquitous Language](#24-ubiquitous-language)
  - [Cap√≠tulo III: Requirements Specification](#cap√≠tulo-iii-requirements-specification)
    - [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
    - [3.2. User Stories](#32-user-stories)
    - [3.3. Product Backlog](#33-product-backlog)
    - [3.4. Impact Mapping](#34-impact-mapping)
  - [Cap√≠tulo IV: Product Design](#cap√≠tulo-iv-product-design)
    - [4.1. Style Guidelines](#41-style-guidelines)
      - [4.1.1. General Style Guidelines](#411-general-style-guidelines)
      - [4.1.2. Web Style Guidelines](#412-web-style-guidelines)
      - [4.1.3. Mobile Style Guidelines](#413-mobile-style-guidelines)
        - [4.1.3.1. iOS Mobile Style Guidelines](#4131-ios-mobile-style-guidelines)
        - [4.1.3.2. Android Mobile Style Guidelines](#4132-android-mobile-style-guidelines)
    - [4.2. Information Architecture](#42-information-architecture)
      - [4.2.1. Organization Systems](#421-organization-systems)
      - [4.2.2. Labeling Systems](#422-labeling-systems)
      - [4.2.3. SEO Tags and Meta Tags](#423-seo-tags-and-meta-tags)
      - [4.2.4. Searching Systems](#424-searching-systems)
      - [4.2.5. Navigation Systems](#425-navigation-systems)
    - [4.3. Landing Page UI Design](#43-landing-page-ui-design)
      - [4.3.1. Landing Page Wireframe](#431-landing-page-wireframe)
      - [4.3.2. Landing Page Mock-up](#432-landing-page-mock-up)
    - [4.4. Mobile Applications UX/UI Design](#44-mobile-applications-uxui-design)
      - [4.4.1. Mobile Applications Wireframes](#441-mobile-applications-wireframes)
      - [4.4.2. Mobile Applications Wireflow Diagrams](#442-mobile-applications-wireflow-diagrams)
      - [4.4.3. Mobile Applications Mock-ups](#443-mobile-applications-mock-ups)
      - [4.4.4. Mobile Applications User Flow Diagrams](#444-mobile-applications-user-flow-diagrams)
    - [4.5. Mobile Applications Prototyping](#45-mobile-applications-prototyping)
      - [4.5.1. Android Mobile Applications Prototyping](#451-android-mobile-applications-prototyping)
      - [4.5.2. iOS Mobile Applications Prototyping](#452-ios-mobile-applications-prototyping)
    - [4.6. Web Applications UX/UI Design](#46-web-applications-uxui-design)
      - [4.6.1. Web Applications Wireframes](#461-web-applications-wireframes)
      - [4.6.2. Web Applications Wireflow Diagrams](#462-web-applications-wireflow-diagrams)
      - [4.6.3. Web Applications Mock-ups](#463-web-applications-mock-ups)
      - [4.6.4. Web Applications User Flow Diagrams](#464-web-applications-user-flow-diagrams)
    - [4.7. Web Applications Prototyping](#47-web-applications-prototyping)
    - [4.8. Domain-Driven Software Architecture](#48-domain-driven-software-architecture)
      - [4.8.1. Software Architecture Context Diagram](#481-software-architecture-context-diagram)
      - [4.8.2. Software Architecture Container Diagrams](#482-software-architecture-container-diagrams)
      - [4.8.3. Software Architecture Components Diagrams](#483-software-architecture-components-diagrams)
    - [4.9. Software Object-Oriented Design](#49-software-object-oriented-design)
      - [4.9.1. Class Diagrams](#491-class-diagrams)
      - [4.9.2. Class Dictionary](#492-class-dictionary)
    - [4.10. Database Design](#410-database-design)
      - [4.10.1. Relational/Non-Relational Database Diagram](#4101-relationalnon-relational-database-diagram)
  - [Cap√≠tulo V: Product Implementation](#cap√≠tulo-v-product-implementation)
    - [5.1. Software Configuration Management](#51-software-configuration-management)
      - [5.1.1. Software Development Environment Configuration](#511-software-development-environment-configuration)
      - [5.1.2. Source Code Management](#512-source-code-management)
      - [5.1.3. Source Code Style Guide & Conventions](#513-source-code-style-guide--conventions)
      - [5.1.4. Software Deployment Configuration](#514-software-deployment-configuration)
    - [5.2. Product Implementation & Deployment](#52-product-implementation--deployment)
      - [5.2.1. Sprint Backlogs](#521-sprint-backlogs)
      - [5.2.2. Implemented Landing Page Evidence](#522-implemented-landing-page-evidence)
      - [5.2.3. Implemented Frontend-Web Application Evidence](#523-implemented-frontend-web-application-evidence)
      - [5.2.4. Acuerdo de Servicio - SaaS](#524-acuerdo-de-servicio---saas)
      - [5.2.5. Implemented Native-Mobile Application Evidence](#525-implemented-native-mobile-application-evidence)
      - [5.2.6. Implemented RESTful API and/or Serverless Backend Evidence](#526-implemented-restful-api-andor-serverless-backend-evidence)
      - [5.2.7. RESTful API documentation](#527-restful-api-documentation)
      - [5.2.8. Team Collaboration Insights](#528-team-collaboration-insights)
    - [5.3. Video About-the-Product](#53-video-about-the-product)
- [Part II: Verification, Validation & Pipeline](#part-ii-verification-validation--pipeline)
  - [Cap√≠tulo VI: Product Verification & Validation](#cap√≠tulo-vi-product-verification--validation)
    - [6.1. Testing Suites & Validation](#61-testing-suites--validation)
      - [6.1.1. Core Entities Unit Tests](#611-core-entities-unit-tests)
      - [6.1.2. Core Integration Tests](#612-core-integration-tests)
      - [6.1.3. Core Behavior-Driven Development](#613-core-behavior-driven-development)
      - [6.1.4. Core System Tests](#614-core-system-tests)
    - [6.2. Static testing & Verification](#62-static-testing--verification)
      - [6.2.1. Static Code Analysis](#621-static-code-analysis)
        - [6.2.1.1. Coding standard & Code conventions](#6211-coding-standard--code-conventions)
        - [6.2.1.2. Code Quality & Code Security](#6212-code-quality--code-security)
      - [6.2.2. Reviews](#622-reviews)
    - [6.3. Validation Interviews](#63-validation-interviews)
      - [6.3.1. Dise√±o de Entrevistas](#631-dise√±o-de-entrevistas)
      - [6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
      - [6.3.3. Evaluaciones seg√∫n heur√≠sticas](#633-evaluaciones-seg√∫n-heur√≠sticas)
    - [6.4. Auditor√≠a de Experiencias de Usuario](#64-auditor√≠a-de-experiencias-de-usuario)
      - [6.4.1. Auditor√≠a realizada](#641-auditor√≠a-realizada)
        - [6.4.1.1. Informaci√≥n del grupo auditado](#6411-informaci√≥n-del-grupo-auditado)
        - [6.4.1.2. Cronograma de auditor√≠a realizada](#6412-cronograma-de-auditor√≠a-realizada)
        - [6.4.1.3. Contenido de auditor√≠a realizada](#6413-contenido-de-auditor√≠a-realizada)
      - [6.4.2. Auditor√≠a recibida](#642-auditor√≠a-recibida)
        - [6.4.2.1. Informaci√≥n del grupo auditor](#6421-informaci√≥n-del-grupo-auditor)
        - [6.4.2.2. Cronograma de auditor√≠a recibida](#6422-cronograma-de-auditor√≠a-recibida)
        - [6.4.2.3. Contenido de auditor√≠a recibida](#6423-contenido-de-auditor√≠a-recibida)
        - [6.4.2.4. Resumen de modificaciones para subsanar hallazgos](#6424-resumen-de-modificaciones-para-subsanar-hallazgos)
  - [Cap√≠tulo VII: DevOps Practices](#cap√≠tulo-vii-devops-practices)
    - [7.1. Continuous Integration](#71-continuous-integration)
      - [7.1.1. Tools and Practices](#711-tools-and-practices)
      - [7.1.2. Build & Test Suite Pipeline Components](#712-build--test-suite-pipeline-components)
    - [7.2. Continuous Delivery](#72-continuous-delivery)
      - [7.2.1. Tools and Practices](#721-tools-and-practices)
      - [7.2.2. Stages Deployment Pipeline Components](#722-stages-deployment-pipeline-components)
    - [7.3. Continuous deployment](#73-continuous-deployment)
      - [7.3.1. Tools and Practices](#731-tools-and-practices)
      - [7.3.2. Production Deployment Pipeline Components](#732-production-deployment-pipeline-components)
    - [7.4. Continuous Monitoring](#74-continuous-monitoring)
      - [7.4.1. Tools and Practices](#741-tools-and-practices)
      - [7.4.2. Monitoring Pipeline Components](#742-monitoring-pipeline-components)
      - [7.4.3. Alerting Pipeline Components](#743-alerting-pipeline-components)
      - [7.4.4. Notification Pipeline Components](#744-notification-pipeline-components)
- [Part III: Experiment-Driven Lifecycle](#part-iii-experiment-driven-lifecycle)
  - [Cap√≠tulo VIII: Experiment-Driven Development](#cap√≠tulo-viii-experiment-driven-development)
    - [8.1. Experiment Planning](#81-experiment-planning)
      - [8.1.1. As-Is Summary](#811-as-is-summary)
      - [8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims](#812-raw-material-assumptions-knowledge-gaps-ideas-claims)
      - [8.1.3. Experiment-Ready Questions](#813-experiment-ready-questions)
      - [8.1.4. Question Backlog](#814-question-backlog)
      - [8.1.5. Experiment Cards](#815-experiment-cards)
    - [8.2. Experiment Design](#82-experiment-design)
      - [8.2.1. Hypotheses](#821-hypotheses)
      - [8.2.2. Domain Business Metrics](#822-domain-business-metrics)
      - [8.2.3. Measures](#823-measures)
      - [8.2.4. Conditions](#824-conditions)
      - [8.2.5. Scale Calculations and Decisions](#825-scale-calculations-and-decisions)
      - [8.2.6. Methods Selection](#826-methods-selection)
      - [8.2.7. Data Analytics: Goals, KPIs and Metrics Selection](#827-data-analytics-goals-kpis-and-metrics-selection)
      - [8.2.8. Web and Mobile Tracking Plan](#828-web-and-mobile-tracking-plan)
    - [8.3. Experimentation](#83-experimentation)
      - [8.3.1. To-Be User Stories](#831-to-be-user-stories)
      - [8.3.2. To-Be Product Backlog](#832-to-be-product-backlog)
      - [8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle](#833-pipeline-supported-experiment-driven-to-be-software-platform-lifecycle)
        - [8.3.3.1. To-Be Sprint Backlogs](#8331-to-be-sprint-backlogs)
        - [8.3.3.2. Implemented To-Be Landing Page Evidence](#8332-implemented-to-be-landing-page-evidence)
        - [8.3.3.3. Implemented To-Be Frontend-Web Application Evidence](#8333-implemented-to-be-frontend-web-application-evidence)
        - [8.3.3.4. Implemented To-Be Native-Mobile Application Evidence](#8334-implemented-to-be-native-mobile-application-evidence)
        - [8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence](#8335-implemented-to-be-restful-api-andor-serverless-backend-evidence)
        - [8.3.3.6. Team Collaboration Insights](#8336-team-collaboration-insights)
      - [8.3.4. To-Be Validation Interviews](#834-to-be-validation-interviews)
        - [8.3.4.1. Dise√±o de Entrevistas](#8341-dise√±o-de-entrevistas)
        - [8.3.4.2. Registro de Entrevistas](#8342-registro-de-entrevistas)
    - [8.4. Experiment Aftermath & Analysis](#84-experiment-aftermath--analysis)
      - [8.4.1. Analysis and Interpretation of Results](#841-analysis-and-interpretation-of-results)
      - [8.4.2. Re-scored and Re-prioritized Question Backlog](#842-re-scored-and-re-prioritized-question-backlog)
    - [8.5. Continuous Learning](#85-continuous-learning)
      - [8.5.1. Shareback Session Artifacts: Learning Workflow](#851-shareback-session-artifacts-learning-workflow)
    - [8.6. To-Be Software Platform Pre-launch](#86-to-be-software-platform-pre-launch)
      - [8.6.1. About-the-Product Intro Video](#861-about-the-product-intro-video)

- [Conclusiones](#conclusiones)
  - [Conclusiones Y Recomendaciones](#conclusiones-y-recomendaciones)
  - [Video App Validation](#video-app-validation)
  - [Video About-the-Team](#video-about-the-team)

- [Bibliograf√≠a](#bibliograf√≠a)

- [Anexos](#anexos)

# Student Outcome

|**Criterio espec√≠fico**|**Acciones realizadas**|**Conclusiones**|
| :-: | :-: | :-: |
| Reconoce responsabilidad √©tica y profesional en situaciones de ingenier√≠a de software | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |
| Emite juicios informados considerando el impacto de las soluciones de ingenier√≠a de software en contextos globales, econ√≥micos, ambientales y sociales | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |

----

# **Part I: As-Is Software Project**

# **Cap√≠tulo I: Introducci√≥n**

## 1.1. Startup Profile

### 1.1.1. Descripci√≥n de la Startup

### 1.1.2. Perfiles de integrantes del equipo

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problem√°tica

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.1. Lean UX Assumptions

#### 1.2.2.1. Lean UX Hypothesis Statements

#### 1.2.2.1. Lean UX Canvas

## 1.3. Segmentos objetivo

# **Cap√≠tulo II: Requirements Elicitation & Analysis**

## 2.1. Competidores

### 2.1.1. An√°lisis competitivo

### 2.1.2. Estrategias y t√°cticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Dise√±o de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. An√°lisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. As-is Scenario Mapping

## 2.4. Ubiquitous Language

# **Cap√≠tulo III: Requirements Specification**

## 3.1. To-Be Scenario Mapping

## 3.2. User Stories

## 3.3. Product Backlog

## 3.4. Impact Mapping

# **Cap√≠tulo IV: Product Design**

## 4.1. Style Guidelines

### 4.1.1. General Style Guidelines

### 4.1.2. Web Style Guidelines

### 4.1.3. Mobile Style Guidelines

#### 4.1.3.1. iOS Mobile Style Guidelines

#### 4.1.3.2. Android Mobile Style Guidelines

## 4.2. Information Architecture

### 4.2.1. Organization Systems

### 4.2.2. Labeling Systems

### 4.2.3. SEO Tags and Meta Tags

### 4.2.4. Searching Systems

### 4.2.5. Navigation Systems

## 4.3. Landing Page UI Design

### 4.3.1. Landing Page Wireframe

### 4.3.2. Landing Page Mock-up

## 4.4. Mobile Applications UX/UI Design

### 4.4.1. Mobile Applications Wireframes

### 4.4.2. Mobile Applications Wireflow Diagrams

### 4.4.3. Mobile Applications Mock-ups

### 4.4.4. Mobile Applications User Flow Diagrams

## 4.5. Mobile Applications Prototyping

### 4.5.1. Android Mobile Applications Prototyping

### 4.5.2. iOS Mobile Applications Prototyping

## 4.6. Web Applications UX/UI Design

### 4.6.1. Web Applications Wireframes

### 4.6.2. Web Applications Wireflow Diagrams

### 4.6.3. Web Applications Mock-ups

### 4.6.4. Web Applications User Flow Diagrams

## 4.7. Web Applications Prototyping

## 4.8. Domain-Driven Software Architecture

### 4.8.1. Software Architecture Context Diagram

### 4.8.2. Software Architecture Container Diagrams

### 4.8.3. Software Architecture Components Diagrams

## 4.9. Software Object-Oriented Design

### 4.9.1. Class Diagrams

### 4.9.2. Class Dictionary

## 4.10. Database Design

### 4.10.1. Relational/Non-Relational Database Diagram

# **Cap√≠tulo V: Product Implementation**

## 5.1. Software Configuration Management

### 5.1.1. Software Development Environment Configuration

### 5.1.2. Source Code Management

### 5.1.3. Source Code Style Guide & Conventions

### 5.1.4. Software Deployment Configuration

## 5.2. Product Implementation & Deployment

### 5.2.1. Sprint Backlogs

### 5.2.2. Implemented Landing Page Evidence

### 5.2.3. Implemented Frontend-Web Application Evidence

### 5.2.4. Acuerdo de Servicio - SaaS

### 5.2.5. Implemented Native-Mobile Application Evidence

### 5.2.6. Implemented RESTful API and/or Serverless Backend Evidence

### 5.2.7. RESTful API documentation

### 5.2.8. Team Collaboration Insights

## 5.3. Video About-the-Product

# **Part II: Verification, Validation & Pipeline**

# **Cap√≠tulo VI: Product Verification & Validation**

## 6.1. Testing Suites & Validation

### 6.1.1. Core Entities Unit Tests

### 6.1.2. Core Integration Tests

### 6.1.3. Core Behavior-Driven Development

### 6.1.4. Core System Tests

## 6.2. Static testing & Verification

### 6.2.1. Static Code Analysis

#### 6.2.1.1. Coding standard & Code conventions

#### 6.2.1.2. Code Quality & Code Security

### 6.2.2. Reviews

## 6.3. Validation Interviews

### 6.3.1. Dise√±o de Entrevistas

### 6.3.2. Registro de Entrevistas

### 6.3.3. Evaluaciones seg√∫n heur√≠sticas

## 6.4. Auditor√≠a de Experiencias de Usuario

### 6.4.1. Auditor√≠a realizada

#### 6.4.1.1. Informaci√≥n del grupo auditado

#### 6.4.1.2. Cronograma de auditor√≠a realizada

#### 6.4.1.3. Contenido de auditor√≠a realizada

### 6.4.2. Auditor√≠a recibida

#### 6.4.2.1. Informaci√≥n del grupo auditor

#### 6.4.2.2. Cronograma de auditor√≠a recibida

#### 6.4.2.3. Contenido de auditor√≠a recibida

#### 6.4.2.4. Resumen de modificaciones para subsanar hallazgos

# **Cap√≠tulo VII: DevOps Practices**

## 7.1. Continuous Integration

Para el proyecto VacApp, desarrollado con React y TypeScript en el frontend y C#/.NET en el backend, se implement√≥ un sistema de Integraci√≥n Continua (CI) mediante GitHub Actions.
Este pipeline automatiza tareas clave como la validaci√≥n del c√≥digo, la verificaci√≥n de tipos, la ejecuci√≥n de pruebas y la preparaci√≥n para el despliegue.
De esta manera, cada commit o pull request activa un flujo de validaciones autom√°ticas que permiten detectar errores tempranamente, mantener la calidad del c√≥digo y asegurar entregas m√°s estables y confiables en los entornos de Azure App Service y Netlify.

### 7.1.1. Tools and Practices
Para la implementaci√≥n de VacApp, desplegamos el frontend en Netlify y el backend en Azure App Service, garantizando un entorno escalable, seguro y de f√°cil mantenimiento.
Adoptamos el flujo Gitflow para la gesti√≥n de ramas en GitHub, junto con Conventional Commits para mantener una estructura clara en los mensajes de commit y SemVer para el versionamiento sem√°ntico.
Implementamos integraci√≥n continua con GitHub Actions, que ejecuta autom√°ticamente validaciones de c√≥digo, an√°lisis est√°tico con ESLint, comprobaci√≥n de tipos con TypeScript, y pruebas automatizadas tanto en el frontend como en el backend.

Para el frontend, empleamos pruebas unitarias y de integraci√≥n usando React Testing Library junto con Vitest, lo que permite verificar la funcionalidad de los componentes y la interacci√≥n del usuario en entornos simulados.
En el backend, utilizamos NUnit como framework de testing principal, complementado con Selenium para realizar pruebas end-to-end sobre la interfaz de usuario, validando la integraci√≥n entre el sistema web y los flujos de usuario reales.
Esta infraestructura de pruebas nos permite detectar errores de manera temprana y asegurar la estabilidad del producto antes de su despliegue.



| Caracter√≠stica     | NUnit | Selenium |
| ------------------ | ----- | -------- |
|                    |  <img width="150" alt="Image" src="https://github.com/user-attachments/assets/f58716a2-722e-4795-80ab-df5e720049cb" />  |    <img width="100" alt="Image" src="https://github.com/user-attachments/assets/061eb064-a4f3-43fe-beb5-870c6308c337" />   |
| Tipo | Framework de testing unitario para .NET| Framework de testing end-to-end para aplicaciones web |
| Lenguaje principal | C#  | Multilenguaje (C#, Java, Python, etc.)         |
| Enfoque            | Pruebas unitarias y de integraci√≥n en el backend       | Pruebas funcionales simulando la interacci√≥n del usuario         |
| Ventajas Clave     | Estructura modular basada en fixtures, assertions y test cases parametrizados. Integraci√≥n directa con Azure DevOps y GitHub Actions.      |  Ejecuci√≥n de pruebas en navegadores reales, automatizaci√≥n de flujos completos y validaci√≥n visual del frontend.        |
| Compatibilidad     | Integraci√≥n con .NET y Azure Pipelines      | Soporte para m√∫ltiples navegadores y entornos CI/C         |
| Tipos de Prueba    | Unitarias, integraci√≥n, regresi√≥n | End-to-End, UI, smoke y regresi√≥n visual|

<br>

**Workflow de Integraci√≥n Continua**
Para asegurar la calidad y consistencia en el desarrollo de VacApp, todos los miembros del equipo siguen el siguiente flujo de trabajo:
	
  
  **1.	Desarrollo local:** Una vez finalizada una feature, el desarrollador ejecuta las pruebas automatizadas con NUnit y Selenium en su entorno local para garantizar la ausencia de errores o regresiones.

**2.	Pull Request:** Si las pruebas son exitosas, se crea una pull request hacia la rama develop, siguiendo el formato de commit definido por Conventional Commits e incluyendo el n√∫mero de la PR (por ejemplo, #23).
  
  **3.	Pipeline autom√°tico:** Al subir la PR al repositorio remoto, GitHub Actions ejecuta autom√°ticamente los pipelines configurados para:
	‚Ä¢	Validar el c√≥digo con ESLint y TypeScript.
	‚Ä¢	Correr las suites de pruebas con NUnit para el backend.
	‚Ä¢	Ejecutar pruebas end-to-end con Selenium sobre entornos controlados.
  
  **4.	Revisi√≥n y pruebas de integraci√≥n:** Una vez aprobada la PR, los cambios se integran a la rama release, donde se ejecutan pruebas de integraci√≥n adicionales en un entorno similar a producci√≥n (Azure Test Environment).
	
  **5.	Despliegue a producci√≥n:** Si las pruebas son exitosas, se aprueba la pull request hacia main, lo que desencadena un despliegue autom√°tico:
	‚Ä¢	Frontend: en Netlify.
	‚Ä¢	Backend: en Azure App Service.
En caso de errores o fallas en los pipelines, el cambio se devuelve a la rama del desarrollador para su correcci√≥n antes de reiniciar el ciclo.

### 7.1.2. Build & Test Suite Pipeline Components
Este documento describe los √âpicos (Epics) principales de la plataforma **Moobile-Platform**, organizados bajo el formato de Historias de Usuario para definir flujos de trabajo clave desde la perspectiva del usuario ganadero.

---

## üêÑ Epic 01: Gesti√≥n de Establos

| Rol | Objetivo | Raz√≥n |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero gestionar los establos en la plataforma** | **Para mantener organizadas las instalaciones** donde se alojan los bovinos. |

<img width="886" height="551" alt="image" src="https://github.com/user-attachments/assets/3ee378e8-3f43-466d-8d6d-fa13cb040a08" />

---

## üêÇ Epic 02: Gesti√≥n de Bovinos

| Rol | Objetivo | Raz√≥n |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero gestionar los bovinos registrados en mis establos** | **Para mantener un control organizado y actualizado** del ganado en la plataforma. |

<img width="886" height="555" alt="image" src="https://github.com/user-attachments/assets/7fc836ea-1302-4f0c-9985-28bbd83cb5a9" />

---

## ‚úèÔ∏è Epic 03: Edici√≥n de Bovinos

| Rol | Objetivo | Raz√≥n |
| :--- | :--- | :--- |
| **Como usuario ganadero,** | **Quiero editar la informaci√≥n de los bovinos,** | **Para actualizar sus datos cuando sea necesario** (peso, edad, raza o estado reproductivo). |

<img width="886" height="565" alt="image" src="https://github.com/user-attachments/assets/504861c5-2bca-42e2-8449-7e1b9f424e26" />

---

## üìÖ Epic 04: Gesti√≥n de Campa√±as

| Rol | Objetivo | Raz√≥n |
| :--- | :--- | :--- |
| **Como empresario ganadero,** | **Quiero gestionar campa√±as sanitarias y de mejoramiento** | **Para coordinar actividades a gran escala** (ej., vacunaci√≥n, suplementaci√≥n) y asegurar el cuidado √≥ptimo. |

<img width="886" height="620" alt="image" src="https://github.com/user-attachments/assets/d7386044-8ab9-44b7-bde3-16bbc1a48164" />

---

## üë®‚Äçüåæ Epic 05: Gesti√≥n de Staff

| Rol | Objetivo | Raz√≥n |
| :--- | :--- | :--- |
| **Como empresario ganadero,** | **Quiero gestionar el personal que trabaja en mi operaci√≥n ganadera** | **Para organizar eficientemente los recursos humanos** y asignar tareas. |

<img width="886" height="634" alt="image" src="https://github.com/user-attachments/assets/7c866db4-f04e-48c6-a965-06e0a2858013" />

## 7.2. Continuous Delivery

En este apartado se puede encontrar tres puntos principales a tomar en cuenta: La automatizaci√≥n de pruebas (pruebas unitarias, pruebas de integraci√≥n y pruebas funcionales y de aceptaci√≥n), el
entorno de pruebas automatizado y las pruebas de rendimiento y carga.

### 7.2.1. Tools and Practices

Para la implementaci√≥n de VacApp, se emplearon distintas herramientas que cubren desde el an√°lisis est√°tico del c√≥digo hasta las pruebas automatizadas y la integraci√≥n continua. El objetivo principal fue garantizar la calidad, estabilidad y mantenibilidad del sistema a trav√©s de un proceso de desarrollo controlado y validado en m√∫ltiples niveles.

**NUnit:** Framework principal de pruebas unitarias para el backend desarrollado en C# y .NET. Permite validar la l√≥gica de negocio definida en los distintos bounded contexts del dominio de VacApp mediante una convenci√≥n de nomenclatura descriptiva, asegurando legibilidad y consistencia. Las pruebas de Core Entities Unit Tests cubren las funcionalidades derivadas de las 28 User Stories implementadas, mientras que las Core Integration Tests validan la interacci√≥n entre componentes, con 3 pruebas por bounded context y 2 para el m√≥dulo IAM (Identity and Access Management).

<img width="220" alt="Image" src="https://github.com/user-attachments/assets/3064c1c8-897d-42ec-a4ea-bbe9cba54b76" />

**Selenium:** Utilizado en los Core System Tests para realizar pruebas end-to-end sobre la interfaz del frontend desarrollado en React y TypeScript, simulando la interacci√≥n real de los usuarios con el sistema. Permite validar los flujos cr√≠ticos del sistema, como autenticaci√≥n, registro de ganado, gesti√≥n de vacunas y campa√±as, asegurando que la aplicaci√≥n funcione correctamente en entornos reales.

<img width="100" alt="Image" src="https://github.com/user-attachments/assets/2ce9c224-5952-4554-849b-bcea88239d17" />

**Cucumber:** Implementado en la capa de Core Behavior-Driven Development (BDD) para la ejecuci√≥n de Acceptance Tests. Las pruebas se redactan en lenguaje Gherkin, lo que facilita la comprensi√≥n tanto por parte del equipo t√©cnico como de los stakeholders no t√©cnicos. Estas pruebas aseguran que cada User Story (US) cumpla con los criterios de aceptaci√≥n definidos, validando comportamientos esperados del sistema desde la perspectiva del usuario final.

<img width="400" alt="Image" src="https://github.com/user-attachments/assets/c40d7548-75c6-42a8-81dd-71921939313a" />

**GitHub Actions:** Sistema de integraci√≥n y despliegue continuo (CI/CD) encargado de automatizar la ejecuci√≥n de pruebas unitarias, de integraci√≥n y end-to-end en cada pull request. Adem√°s, realiza validaciones de c√≥digo con ESLint y an√°lisis de tipado con TypeScript, garantizando la calidad del c√≥digo antes de fusionar los cambios en la rama principal del proyecto.

<img width="170" height="132" alt="Image" src="https://github.com/user-attachments/assets/e98893cf-36ab-448e-907c-a7c3cfacf6bf" />

**ESLint y TypeScript:** Se utilizan de manera conjunta en el frontend para mantener un c√≥digo limpio, consistente y seguro. ESLint aplica reglas personalizadas de estilo, seguridad y buenas pr√°cticas en React, mientras que TypeScript ofrece comprobaci√≥n est√°tica de tipos, minimizando errores en tiempo de ejecuci√≥n y mejorando la mantenibilidad a largo plazo.

<img height="100" alt="Image" src="https://github.com/user-attachments/assets/2bbde38e-6843-43b9-b311-345b040a3bf7" />

**Azure App Service:** Servicio en la nube de Microsoft Azure utilizado para desplegar y administrar el backend desarrollado en .NET. Ofrece integraci√≥n directa con GitHub Actions, soporte para despliegues automatizados y escalabilidad bajo demanda. Permite realizar pruebas en entornos preconfigurados, gestionar logs y monitorear el rendimiento del sistema de manera continua.

<img width="200" alt="image" src="https://github.com/user-attachments/assets/e4b90ae3-e64f-4e85-968f-8ad3d5bfdc6f" />

**Netlify:** Plataforma utilizada para el despliegue del frontend desarrollado en React y TypeScript. Ofrece integraci√≥n continua con GitHub, lo que permite realizar despliegues autom√°ticos tras cada merge en la rama principal. Adem√°s, proporciona un entorno de hosting r√°pido, seguro y con soporte para HTTPS, control de versiones y previsualizaci√≥n de cambios antes del despliegue final.

<img width="200" alt="Image" src="https://github.com/user-attachments/assets/bd3f8e61-bc2b-4be1-8a8e-2500840f4e07" />

---

### 7.2.2. Stages Deployment Pipeline Components

A continuaci√≥n, se describen las etapas del pipeline de despliegue implementado en el proyecto **VacApp**.  
Cada fase fue dise√±ada para garantizar una entrega continua, confiable y de alta calidad del software, asegurando la integraci√≥n fluida entre el **frontend (React + TypeScript)** y el **backend (.NET + C#)**.

**1. Code Commit**
El proceso se inicia cuando un desarrollador realiza un commit en el repositorio de c√≥digo.  
Se utiliza **Git** como sistema de control de versiones y **GitHub** como plataforma de alojamiento.  
Todos los commits siguen la convenci√≥n de **Conventional Commits** para mantener mensajes claros, estructurados y compatibles con **SemVer** (versionado sem√°ntico).

**2. Linting y Verificaci√≥n de Tipos**
En esta etapa se ejecutan herramientas de an√°lisis est√°tico del c√≥digo en el **frontend**, utilizando **ESLint** para validar la calidad y estilo, y **TypeScript** para la comprobaci√≥n estricta de tipos.  
Esta validaci√≥n temprana asegura la robustez del c√≥digo y previene errores antes de llegar a etapas posteriores del pipeline.

**3. Build**
El c√≥digo del **frontend** se compila con **Vite** y **TypeScript**, generando los artefactos listos para despliegue en **Netlify**.  
Simult√°neamente, el **backend** se compila en **.NET SDK**, verificando la integridad de dependencias, controladores, entidades y servicios.  
Esta fase asegura que no existan errores de compilaci√≥n y que el sistema est√© preparado para las pruebas automatizadas.

**4. Test Unitarios**
Se ejecutan las pruebas unitarias mediante **NUnit** para el backend, cubriendo las **Core Entities Unit Tests** y asegurando el correcto funcionamiento de la l√≥gica de negocio individual.  
Cada prueba sigue una convenci√≥n descriptiva (*M√©todo_DadaCondici√≥n_Deber√≠aResultadoEsperado*) que mejora la mantenibilidad y claridad de los resultados.

**5. Test de Integraci√≥n**
Durante esta etapa se ejecutan las **Core Integration Tests** con **NUnit**, validando la interacci√≥n entre los distintos **bounded contexts** del dominio y los m√≥dulos de infraestructura.  
Cada contexto incluye tres pruebas principales, adem√°s de dos pruebas espec√≠ficas para el m√≥dulo **IAM (Identity and Access Management)**.

**6. Test End-to-End**
Las **Core System Tests** se ejecutan con **Selenium**, simulando la interacci√≥n real de los usuarios sobre la interfaz web desarrollada en **React**.  
Estas pruebas validan los flujos cr√≠ticos como el inicio de sesi√≥n, la gesti√≥n de bovinos, vacunas y campa√±as, garantizando la correcta experiencia de usuario final.

**7. Acceptance Tests (BDD)**
En esta fase se ejecutan pruebas **Behavior-Driven Development (BDD)** con **Cucumber**, empleando el lenguaje **Gherkin** para validar las 28 **User Stories (US)** del sistema.  
Cada escenario describe comportamientos esperados desde la perspectiva del usuario, facilitando la validaci√≥n del producto frente a los criterios de aceptaci√≥n definidos.

**8. Staging Deployment**
Tras superar las fases de prueba, el sistema se despliega autom√°ticamente en un entorno de **staging**:
- **Backend:** desplegado en **Azure App Service**, replicando el entorno productivo.  
- **Frontend:** desplegado en **Netlify**, permitiendo previsualizar la versi√≥n antes del lanzamiento final.  
En esta etapa se realizan pruebas adicionales de integraci√≥n, rendimiento y conectividad entre servicios.

**9. Production Release**
Luego de la aprobaci√≥n en *staging*, los cambios son fusionados en la rama `main`.  
El pipeline de **GitHub Actions** ejecuta el **despliegue autom√°tico a producci√≥n**, publicando:
- El **frontend** en **Netlify**.  
- El **backend** en **Azure App Service**.  
Este proceso asegura un flujo continuo y sin intervenci√≥n manual, reduciendo tiempos de entrega y errores humanos.

**10. Monitoreo Post-Despliegue**
Una vez en producci√≥n, **VacApp** es monitoreada continuamente para verificar su rendimiento y estabilidad.  
El backend utiliza **Azure Monitor** y **Application Insights** para el registro estructurado, m√©tricas de uso y detecci√≥n temprana de errores.  
Asimismo, se supervisa la disponibilidad del frontend mediante herramientas integradas en **Netlify Analytics**, garantizando una respuesta r√°pida ante cualquier incidencia.

## 7.3. Continuous deployment

El despliegue continuo es una pr√°ctica fundamental en el desarrollo de software moderno, que automatiza la entrega de cambios al entorno de producci√≥n. En esta secci√≥n se describen las
herramientas y procesos implementados para asegurar un flujo de trabajo eficiente, permitiendo que el software sea desplegado de manera r√°pida, segura y consistente.

### 7.3.1. Tools and Practices

**GitHub Actions:**
Es el motor principal de automatizaci√≥n CI/CD en el proyecto VacApp.
Se configuraron flujos de trabajo que se ejecutan autom√°ticamente ante cada push o pull request en el repositorio.
Estos pipelines realizan una serie de validaciones, incluyendo an√°lisis est√°tico de c√≥digo con ESLint, verificaci√≥n de tipos con TypeScript, ejecuci√≥n de pruebas unitarias con NUnit, pruebas de integraci√≥n en los distintos bounded contexts, y pruebas end-to-end con Selenium.
En caso de que todas las verificaciones sean exitosas, se procede al despliegue autom√°tico del backend en Azure App Service y del frontend en Netlify, garantizando una entrega continua, estable y confiable del sistema.

<img width="170" height="132" alt="Image" src="https://github.com/user-attachments/assets/e98893cf-36ab-448e-907c-a7c3cfacf6bf" />

**Azure App Service:**
Es la plataforma utilizada para el despliegue del backend de VacApp desarrollado en .NET.
Permite integrar directamente el flujo de despliegue con GitHub Actions, ofreciendo un entorno administrado con soporte para scaling, monitoreo de rendimiento y gesti√≥n de versiones.
Su infraestructura automatizada facilita el despliegue sin intervenci√≥n manual, reduciendo el riesgo de errores y mejorando los tiempos de entrega a producci√≥n.

<img width="200" alt="image" src="https://github.com/user-attachments/assets/e4b90ae3-e64f-4e85-968f-8ad3d5bfdc6f" />

**Netlify:**
Es la plataforma utilizada para el despliegue del frontend de VacApp, desarrollado en React y TypeScript.
Netlify proporciona integraci√≥n nativa con GitHub, lo que permite generar previews autom√°ticos de cada rama y realizar el despliegue final al aprobar los cambios en la rama principal.
Adem√°s, ofrece soporte para HTTPS, control de versiones y optimizaci√≥n autom√°tica del contenido est√°tico, garantizando alto rendimiento en el entorno productivo.

<img width="200" alt="Image" src="https://github.com/user-attachments/assets/bd3f8e61-bc2b-4be1-8a8e-2500840f4e07" />

**ESLint + Prettier:**
Herramientas integradas en el pipeline de CI/CD para garantizar la calidad, legibilidad y consistencia del c√≥digo en el frontend.
ESLint aplica reglas personalizadas espec√≠ficas para proyectos en TypeScript y React, detectando errores de estilo, malas pr√°cticas y vulnerabilidades potenciales.
Por su parte, Prettier asegura un formato uniforme en todo el c√≥digo, siguiendo los est√°ndares definidos por el equipo de desarrollo, como el uso de comillas simples, indentaci√≥n consistente y trailing commas.
En conjunto, estas herramientas ayudan a mantener un c√≥digo limpio, profesional y coherente entre todos los miembros del equipo.

<img width="301" height="167" alt="Image" src="https://github.com/user-attachments/assets/50cf0805-3b56-47ce-9151-de76d32da20a" />

### 7.3.2. Production Deployment Pipeline Components

## 7.4. Continuous Monitoring

### 7.4.1. Tools and Practices

### 7.4.2. Monitoring Pipeline Components

### 7.4.3. Alerting Pipeline Components

### 7.4.4. Notification Pipeline Components

# **Part III: Experiment-Driven Lifecycle**

# **Cap√≠tulo VIII: Experiment-Driven Development**

## 8.1. Experiment Planning

### 8.1.1. As-Is Summary

### 8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims

### 8.1.3. Experiment-Ready Questions

### 8.1.4. Question Backlog

### 8.1.5. Experiment Cards

## 8.2. Experiment Design

### 8.2.1. Hypotheses

### 8.2.2. Domain Business Metrics

### 8.2.3. Measures

### 8.2.4. Conditions

### 8.2.5. Scale Calculations and Decisions

### 8.2.6. Methods Selection

### 8.2.7. Data Analytics: Goals, KPIs and Metrics Selection

### 8.2.8. Web and Mobile Tracking Plan

## 8.3. Experimentation

### 8.3.1. To-Be User Stories

### 8.3.2. To-Be Product Backlog

### 8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle

#### 8.3.3.1. To-Be Sprint Backlogs

#### 8.3.3.2. Implemented To-Be Landing Page Evidence

#### 8.3.3.3. Implemented To-Be Frontend-Web Application Evidence

#### 8.3.3.4. Implemented To-Be Native-Mobile Application Evidence

#### 8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence

#### 8.3.3.6. Team Collaboration Insights

### 8.3.4. To-Be Validation Interviews

#### 8.3.4.1. Dise√±o de Entrevistas

#### 8.3.4.2. Registro de Entrevistas

## 8.4. Experiment Aftermath & Analysis

### 8.4.1. Analysis and Interpretation of Results

### 8.4.2. Re-scored and Re-prioritized Question Backlog

## 8.5. Continuous Learning

### 8.5.1. Shareback Session Artifacts: Learning Workflow

## 8.6. To-Be Software Platform Pre-launch

### 8.6.1. About-the-Product Intro Video

----

# Conclusiones

## Conclusiones Y Recomendaciones

## Video App Validation

## Video About-the-Team

----

# Bibliograf√≠a

----

# Anexos
