<div align="center">
  <h3> Universidad Peruana de Ciencias Aplicadas </h3>

<img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png" alt="Imagen centrada" width="200"/>

  <h5> Ingeniería de Software </h5>

  <h5> Diseño de Experimentos de Ingeniería de Software </h5>

  <h5> NRC: 14651 </h5>

  <h5> Docente: Juan Carlos Tinoco Licas </h5>

  <h5> Informe del Trabajo Final </h5>

  <h5> Startup: Cowders </h5>

  <h5> Producto: Moobile </h5>
</div>

<div align="center">
    <h3>Integrantes:</h3>
</div>

<div>
     <table align="center">
        <tr>
            <th style="text-align:center;">Apellidos y nombres</th>
            <th style="text-align:center;">Código</th>
        </tr>
        <tr>
            <td>Bravo Gavilano, Jorge Rafael</td>
            <td>U202212535</td>
        </tr>
        <tr>
            <td>Gonzalez Custodio, Carlos Alberto</td>
            <td>U202020230</td>
        </tr>
        <tr>
            <td>Martinez Ramos, Bryan Felix</td>
            <td>U202316246</td>
        </tr>
        <tr>
            <td>Roque Tello, Jack Eddie</td>
            <td>U20221C448</td>
        </tr>
        <tr>
            <td>Silva Morales, Renzo Cesar</td>
            <td>U20221C362</td>
        </tr>
    </table>
</div>

<div align="center">
<h5> Setiembre 2025 </h5>
</div>

## Registro de versiones del informe

|**Versión**|**Fecha**|**Autor**|**Descripción de modificación**|
| :-: | :-: | :-: | :-: |
|1\.0|10/09/2025|Moobile|Redacción de los Capítulos I: Introducción, II: Requirements Elicitation & Analysis, III: Requirements Specification, IV: Product Design y V: Product Implementation|

# Project Report Collaboration Insights

# Contenido

## Tabla de contenidos

- [Registro de versiones del informe](#registro-de-versiones-del-informe)
- [Project Report Collaboration Insights](#project-report-collaboration-insights)
- [Contenido](#contenido)
  - [Tabla de contenidos](#tabla-de-contenidos)
- [Student Outcome](#student-outcome)
- [Part I: As-Is Software Project](#part-i-as-is-software-project)
  - [Capítulo I: Introducción](#capítulo-i-introducción)
    - [1.1. Startup Profile](#11-startup-profile)
      - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
      - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
    - [1.2. Solution Profile](#12-solution-profile)
      - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
      - [1.2.2. Lean UX Process](#122-lean-ux-process)
        - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
        - [1.2.2.1. Lean UX Assumptions](#1221-lean-ux-assumptions)
        - [1.2.2.1. Lean UX Hypothesis Statements](#1221-lean-ux-hypothesis-statements)
        - [1.2.2.1. Lean UX Canvas](#1221-lean-ux-canvas)
    - [1.3. Segmentos objetivo](#13-segmentos-objetivo)
  - [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
    - [2.1. Competidores](#21-competidores)
      - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
      - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
    - [2.2. Entrevistas](#22-entrevistas)
      - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
      - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
      - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
    - [2.3. Needfinding](#23-needfinding)
      - [2.3.1. User Personas](#231-user-personas)
      - [2.3.2. User Task Matrix](#232-user-task-matrix)
      - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
      - [2.3.4. Empathy Mapping](#234-empathy-mapping)
      - [2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping)
    - [2.4. Ubiquitous Language](#24-ubiquitous-language)
  - [Capítulo III: Requirements Specification](#capítulo-iii-requirements-specification)
    - [3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)
    - [3.2. User Stories](#32-user-stories)
    - [3.3. Product Backlog](#33-product-backlog)
    - [3.4. Impact Mapping](#34-impact-mapping)
  - [Capítulo IV: Product Design](#capítulo-iv-product-design)
    - [4.1. Style Guidelines](#41-style-guidelines)
      - [4.1.1. General Style Guidelines](#411-general-style-guidelines)
      - [4.1.2. Web Style Guidelines](#412-web-style-guidelines)
      - [4.1.3. Mobile Style Guidelines](#413-mobile-style-guidelines)
        - [4.1.3.1. iOS Mobile Style Guidelines](#4131-ios-mobile-style-guidelines)
        - [4.1.3.2. Android Mobile Style Guidelines](#4132-android-mobile-style-guidelines)
    - [4.2. Information Architecture](#42-information-architecture)
      - [4.2.1. Organization Systems](#421-organization-systems)
      - [4.2.2. Labeling Systems](#422-labeling-systems)
      - [4.2.3. SEO Tags and Meta Tags](#423-seo-tags-and-meta-tags)
      - [4.2.4. Searching Systems](#424-searching-systems)
      - [4.2.5. Navigation Systems](#425-navigation-systems)
    - [4.3. Landing Page UI Design](#43-landing-page-ui-design)
      - [4.3.1. Landing Page Wireframe](#431-landing-page-wireframe)
      - [4.3.2. Landing Page Mock-up](#432-landing-page-mock-up)
    - [4.4. Mobile Applications UX/UI Design](#44-mobile-applications-uxui-design)
      - [4.4.1. Mobile Applications Wireframes](#441-mobile-applications-wireframes)
      - [4.4.2. Mobile Applications Wireflow Diagrams](#442-mobile-applications-wireflow-diagrams)
      - [4.4.3. Mobile Applications Mock-ups](#443-mobile-applications-mock-ups)
      - [4.4.4. Mobile Applications User Flow Diagrams](#444-mobile-applications-user-flow-diagrams)
    - [4.5. Mobile Applications Prototyping](#45-mobile-applications-prototyping)
      - [4.5.1. Android Mobile Applications Prototyping](#451-android-mobile-applications-prototyping)
      - [4.5.2. iOS Mobile Applications Prototyping](#452-ios-mobile-applications-prototyping)
    - [4.6. Web Applications UX/UI Design](#46-web-applications-uxui-design)
      - [4.6.1. Web Applications Wireframes](#461-web-applications-wireframes)
      - [4.6.2. Web Applications Wireflow Diagrams](#462-web-applications-wireflow-diagrams)
      - [4.6.3. Web Applications Mock-ups](#463-web-applications-mock-ups)
      - [4.6.4. Web Applications User Flow Diagrams](#464-web-applications-user-flow-diagrams)
    - [4.7. Web Applications Prototyping](#47-web-applications-prototyping)
    - [4.8. Domain-Driven Software Architecture](#48-domain-driven-software-architecture)
      - [4.8.1. Software Architecture Context Diagram](#481-software-architecture-context-diagram)
      - [4.8.2. Software Architecture Container Diagrams](#482-software-architecture-container-diagrams)
      - [4.8.3. Software Architecture Components Diagrams](#483-software-architecture-components-diagrams)
    - [4.9. Software Object-Oriented Design](#49-software-object-oriented-design)
      - [4.9.1. Class Diagrams](#491-class-diagrams)
      - [4.9.2. Class Dictionary](#492-class-dictionary)
    - [4.10. Database Design](#410-database-design)
      - [4.10.1. Relational/Non-Relational Database Diagram](#4101-relationalnon-relational-database-diagram)
  - [Capítulo V: Product Implementation](#capítulo-v-product-implementation)
    - [5.1. Software Configuration Management](#51-software-configuration-management)
      - [5.1.1. Software Development Environment Configuration](#511-software-development-environment-configuration)
      - [5.1.2. Source Code Management](#512-source-code-management)
      - [5.1.3. Source Code Style Guide & Conventions](#513-source-code-style-guide--conventions)
      - [5.1.4. Software Deployment Configuration](#514-software-deployment-configuration)
    - [5.2. Product Implementation & Deployment](#52-product-implementation--deployment)
      - [5.2.1. Sprint Backlogs](#521-sprint-backlogs)
      - [5.2.2. Implemented Landing Page Evidence](#522-implemented-landing-page-evidence)
      - [5.2.3. Implemented Frontend-Web Application Evidence](#523-implemented-frontend-web-application-evidence)
      - [5.2.4. Acuerdo de Servicio - SaaS](#524-acuerdo-de-servicio---saas)
      - [5.2.5. Implemented Native-Mobile Application Evidence](#525-implemented-native-mobile-application-evidence)
      - [5.2.6. Implemented RESTful API and/or Serverless Backend Evidence](#526-implemented-restful-api-andor-serverless-backend-evidence)
      - [5.2.7. RESTful API documentation](#527-restful-api-documentation)
      - [5.2.8. Team Collaboration Insights](#528-team-collaboration-insights)
    - [5.3. Video About-the-Product](#53-video-about-the-product)
- [Part II: Verification, Validation & Pipeline](#part-ii-verification-validation--pipeline)
  - [Capítulo VI: Product Verification & Validation](#capítulo-vi-product-verification--validation)
    - [6.1. Testing Suites & Validation](#61-testing-suites--validation)
      - [6.1.1. Core Entities Unit Tests](#611-core-entities-unit-tests)
      - [6.1.2. Core Integration Tests](#612-core-integration-tests)
      - [6.1.3. Core Behavior-Driven Development](#613-core-behavior-driven-development)
      - [6.1.4. Core System Tests](#614-core-system-tests)
    - [6.2. Static testing & Verification](#62-static-testing--verification)
      - [6.2.1. Static Code Analysis](#621-static-code-analysis)
        - [6.2.1.1. Coding standard & Code conventions](#6211-coding-standard--code-conventions)
        - [6.2.1.2. Code Quality & Code Security](#6212-code-quality--code-security)
      - [6.2.2. Reviews](#622-reviews)
    - [6.3. Validation Interviews](#63-validation-interviews)
      - [6.3.1. Diseño de Entrevistas](#631-diseño-de-entrevistas)
      - [6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
      - [6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-según-heurísticas)
    - [6.4. Auditoría de Experiencias de Usuario](#64-auditoría-de-experiencias-de-usuario)
      - [6.4.1. Auditoría realizada](#641-auditoría-realizada)
        - [6.4.1.1. Información del grupo auditado](#6411-información-del-grupo-auditado)
        - [6.4.1.2. Cronograma de auditoría realizada](#6412-cronograma-de-auditoría-realizada)
        - [6.4.1.3. Contenido de auditoría realizada](#6413-contenido-de-auditoría-realizada)
      - [6.4.2. Auditoría recibida](#642-auditoría-recibida)
        - [6.4.2.1. Información del grupo auditor](#6421-información-del-grupo-auditor)
        - [6.4.2.2. Cronograma de auditoría recibida](#6422-cronograma-de-auditoría-recibida)
        - [6.4.2.3. Contenido de auditoría recibida](#6423-contenido-de-auditoría-recibida)
        - [6.4.2.4. Resumen de modificaciones para subsanar hallazgos](#6424-resumen-de-modificaciones-para-subsanar-hallazgos)
  - [Capítulo VII: DevOps Practices](#capítulo-vii-devops-practices)
    - [7.1. Continuous Integration](#71-continuous-integration)
      - [7.1.1. Tools and Practices](#711-tools-and-practices)
      - [7.1.2. Build & Test Suite Pipeline Components](#712-build--test-suite-pipeline-components)
    - [7.2. Continuous Delivery](#72-continuous-delivery)
      - [7.2.1. Tools and Practices](#721-tools-and-practices)
      - [7.2.2. Stages Deployment Pipeline Components](#722-stages-deployment-pipeline-components)
    - [7.3. Continuous deployment](#73-continuous-deployment)
      - [7.3.1. Tools and Practices](#731-tools-and-practices)
      - [7.3.2. Production Deployment Pipeline Components](#732-production-deployment-pipeline-components)
    - [7.4. Continuous Monitoring](#74-continuous-monitoring)
      - [7.4.1. Tools and Practices](#741-tools-and-practices)
      - [7.4.2. Monitoring Pipeline Components](#742-monitoring-pipeline-components)
      - [7.4.3. Alerting Pipeline Components](#743-alerting-pipeline-components)
      - [7.4.4. Notification Pipeline Components](#744-notification-pipeline-components)
- [Part III: Experiment-Driven Lifecycle](#part-iii-experiment-driven-lifecycle)
  - [Capítulo VIII: Experiment-Driven Development](#capítulo-viii-experiment-driven-development)
    - [8.1. Experiment Planning](#81-experiment-planning)
      - [8.1.1. As-Is Summary](#811-as-is-summary)
      - [8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims](#812-raw-material-assumptions-knowledge-gaps-ideas-claims)
      - [8.1.3. Experiment-Ready Questions](#813-experiment-ready-questions)
      - [8.1.4. Question Backlog](#814-question-backlog)
      - [8.1.5. Experiment Cards](#815-experiment-cards)
    - [8.2. Experiment Design](#82-experiment-design)
      - [8.2.1. Hypotheses](#821-hypotheses)
      - [8.2.2. Domain Business Metrics](#822-domain-business-metrics)
      - [8.2.3. Measures](#823-measures)
      - [8.2.4. Conditions](#824-conditions)
      - [8.2.5. Scale Calculations and Decisions](#825-scale-calculations-and-decisions)
      - [8.2.6. Methods Selection](#826-methods-selection)
      - [8.2.7. Data Analytics: Goals, KPIs and Metrics Selection](#827-data-analytics-goals-kpis-and-metrics-selection)
      - [8.2.8. Web and Mobile Tracking Plan](#828-web-and-mobile-tracking-plan)
    - [8.3. Experimentation](#83-experimentation)
      - [8.3.1. To-Be User Stories](#831-to-be-user-stories)
      - [8.3.2. To-Be Product Backlog](#832-to-be-product-backlog)
      - [8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle](#833-pipeline-supported-experiment-driven-to-be-software-platform-lifecycle)
        - [8.3.3.1. To-Be Sprint Backlogs](#8331-to-be-sprint-backlogs)
        - [8.3.3.2. Implemented To-Be Landing Page Evidence](#8332-implemented-to-be-landing-page-evidence)
        - [8.3.3.3. Implemented To-Be Frontend-Web Application Evidence](#8333-implemented-to-be-frontend-web-application-evidence)
        - [8.3.3.4. Implemented To-Be Native-Mobile Application Evidence](#8334-implemented-to-be-native-mobile-application-evidence)
        - [8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence](#8335-implemented-to-be-restful-api-andor-serverless-backend-evidence)
        - [8.3.3.6. Team Collaboration Insights](#8336-team-collaboration-insights)
      - [8.3.4. To-Be Validation Interviews](#834-to-be-validation-interviews)
        - [8.3.4.1. Diseño de Entrevistas](#8341-diseño-de-entrevistas)
        - [8.3.4.2. Registro de Entrevistas](#8342-registro-de-entrevistas)
    - [8.4. Experiment Aftermath & Analysis](#84-experiment-aftermath--analysis)
      - [8.4.1. Analysis and Interpretation of Results](#841-analysis-and-interpretation-of-results)
      - [8.4.2. Re-scored and Re-prioritized Question Backlog](#842-re-scored-and-re-prioritized-question-backlog)
    - [8.5. Continuous Learning](#85-continuous-learning)
      - [8.5.1. Shareback Session Artifacts: Learning Workflow](#851-shareback-session-artifacts-learning-workflow)
    - [8.6. To-Be Software Platform Pre-launch](#86-to-be-software-platform-pre-launch)
      - [8.6.1. About-the-Product Intro Video](#861-about-the-product-intro-video)

- [Conclusiones](#conclusiones)
  - [Conclusiones Y Recomendaciones](#conclusiones-y-recomendaciones)
  - [Video App Validation](#video-app-validation)
  - [Video About-the-Team](#video-about-the-team)

- [Bibliografía](#bibliografía)

- [Anexos](#anexos)

# Student Outcome

|**Criterio específico**|**Acciones realizadas**|**Conclusiones**|
| :-: | :-: | :-: |
| Reconoce responsabilidad ética y profesional en situaciones de ingeniería de software | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |
| Emite juicios informados considerando el impacto de las soluciones de ingeniería de software en contextos globales, económicos, ambientales y sociales | Bravo Gavilano, Jorge Rafael<br>*TB1*<br><br>Gonzalez Custodio, Carlos Alberto<br>*TB1*<br><br>Martinez Ramos, Bryan Felix<br>*TB1*<br><br>Roque Tello, Jack Eddie<br>*TB1*<br><br>Silva Morales, Renzo Cesar<br>*TB1*  | *TB1* <br> |

----

# **Part I: As-Is Software Project**

# **Capítulo I: Introducción**

## 1.1. Startup Profile

### 1.1.1. Descripción de la Startup

### 1.1.2. Perfiles de integrantes del equipo

## 1.2. Solution Profile

### 1.2.1. Antecedentes y problemática

### 1.2.2. Lean UX Process

#### 1.2.2.1. Lean UX Problem Statements

#### 1.2.2.1. Lean UX Assumptions

#### 1.2.2.1. Lean UX Hypothesis Statements

#### 1.2.2.1. Lean UX Canvas

## 1.3. Segmentos objetivo

# **Capítulo II: Requirements Elicitation & Analysis**

## 2.1. Competidores

### 2.1.1. Análisis competitivo

### 2.1.2. Estrategias y tácticas frente a competidores

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

### 2.2.2. Registro de entrevistas

### 2.2.3. Análisis de entrevistas

## 2.3. Needfinding

### 2.3.1. User Personas

### 2.3.2. User Task Matrix

### 2.3.3. User Journey Mapping

### 2.3.4. Empathy Mapping

### 2.3.5. As-is Scenario Mapping

## 2.4. Ubiquitous Language

# **Capítulo III: Requirements Specification**

## 3.1. To-Be Scenario Mapping

## 3.2. User Stories

## 3.3. Product Backlog

## 3.4. Impact Mapping

# **Capítulo IV: Product Design**

## 4.1. Style Guidelines

### 4.1.1. General Style Guidelines

### 4.1.2. Web Style Guidelines

### 4.1.3. Mobile Style Guidelines

#### 4.1.3.1. iOS Mobile Style Guidelines

#### 4.1.3.2. Android Mobile Style Guidelines

## 4.2. Information Architecture

### 4.2.1. Organization Systems

### 4.2.2. Labeling Systems

### 4.2.3. SEO Tags and Meta Tags

### 4.2.4. Searching Systems

### 4.2.5. Navigation Systems

## 4.3. Landing Page UI Design

### 4.3.1. Landing Page Wireframe

### 4.3.2. Landing Page Mock-up

## 4.4. Mobile Applications UX/UI Design

### 4.4.1. Mobile Applications Wireframes

### 4.4.2. Mobile Applications Wireflow Diagrams

### 4.4.3. Mobile Applications Mock-ups

### 4.4.4. Mobile Applications User Flow Diagrams

## 4.5. Mobile Applications Prototyping

### 4.5.1. Android Mobile Applications Prototyping

### 4.5.2. iOS Mobile Applications Prototyping

## 4.6. Web Applications UX/UI Design

### 4.6.1. Web Applications Wireframes

### 4.6.2. Web Applications Wireflow Diagrams

### 4.6.3. Web Applications Mock-ups

### 4.6.4. Web Applications User Flow Diagrams

## 4.7. Web Applications Prototyping

## 4.8. Domain-Driven Software Architecture

### 4.8.1. Software Architecture Context Diagram

### 4.8.2. Software Architecture Container Diagrams

### 4.8.3. Software Architecture Components Diagrams

## 4.9. Software Object-Oriented Design

### 4.9.1. Class Diagrams

### 4.9.2. Class Dictionary

## 4.10. Database Design

### 4.10.1. Relational/Non-Relational Database Diagram

# **Capítulo V: Product Implementation**

## 5.1. Software Configuration Management

### 5.1.1. Software Development Environment Configuration

### 5.1.2. Source Code Management

### 5.1.3. Source Code Style Guide & Conventions

### 5.1.4. Software Deployment Configuration

## 5.2. Product Implementation & Deployment

### 5.2.1. Sprint Backlogs

### 5.2.2. Implemented Landing Page Evidence

### 5.2.3. Implemented Frontend-Web Application Evidence

### 5.2.4. Acuerdo de Servicio - SaaS

### 5.2.5. Implemented Native-Mobile Application Evidence

### 5.2.6. Implemented RESTful API and/or Serverless Backend Evidence

### 5.2.7. RESTful API documentation

### 5.2.8. Team Collaboration Insights

## 5.3. Video About-the-Product

# **Part II: Verification, Validation & Pipeline**

# **Capítulo VI: Product Verification & Validation**

## 6.1. Testing Suites & Validation

### 6.1.1. Core Entities Unit Tests
El proyecto Moobile.Platform.Domain.Tests contiene las pruebas unitarias de las entidades principales del dominio de la plataforma Moobile. Estas pruebas garantizan la correcta funcionalidad de los módulos base definidos en las historias de usuario correspondientes a la gestión de establos, bovinos, vacunas, campañas y personal (staff).

Cada conjunto de pruebas se encuentra organizado en carpetas según la entidad a la que pertenece, manteniendo así una estructura modular y de fácil mantenimiento.

#### Estructura general del proyecto de pruebas
```
Moobile.Platform.Domain.Tests
 ├── Bovine
 │   └── BovineTests.cs
 ├── Campaign
 │   └── CampaignTests.cs
 ├── Shared
 │   ├── CampaignCommandFactory.cs
 │   ├── RanchManagementCommandFactory.cs
 │   └── StaffCommandFactory.cs
 ├── Stable
 │   └── StableTests.cs
 ├── Staff
 │   └── StaffTests.cs
 └── Vaccine
     └── VaccineTests.cs

```
#### Cobertura de pruebas por módulo
- Gestión de Establos (EP01)
Las pruebas implementadas en StableTests.cs validan los casos definidos en las historias de usuario US01–US05, abarcando la creación, visualización, edición, eliminación y búsqueda de establos. Se comprueba que las operaciones CRUD se ejecuten correctamente y que las reglas de negocio (como capacidad o nombre único) sean respetadas.

- Gestión de Bovinos (EP02)
El archivo BovineTests.cs cubre las funcionalidades descritas en las historias US06–US11, relacionadas con el registro, visualización, actualización, eliminación, búsqueda y asignación de bovinos a establos. Las pruebas verifican la integridad de los datos y la correcta asociación entre bovinos y establos.

- Gestión de Vacunas (EP03)
En VaccineTests.cs se implementan las pruebas para las historias US12–US17, que incluyen el registro, consulta, modificación, eliminación, búsqueda y asignación de vacunas a bovinos. Estas pruebas aseguran la consistencia del historial sanitario y la relación entre vacunas y animales.

- Gestión de Campañas (EP04)
El archivo CampaignTests.cs valida las historias US18–US22, garantizando el correcto manejo de campañas sanitarias o de mejoramiento, incluyendo su creación, consulta, actualización, eliminación y búsqueda por fecha.

- Gestión de Personal (EP05)
Las pruebas en StaffTests.cs verifican las historias US23–US28, enfocadas en el registro, visualización, edición, eliminación, búsqueda y asignación del personal a campañas. Se valida la consistencia de roles y asignaciones dentro del sistema.

### 6.1.2. Core Integration Tests

En este apartado, se describe cómo se llevaron a cabo las pruebas de integración para verificar que los distintos módulos o bounded contexts del sistema operen adecuadamente al interactuar entre sí.  
El objetivo principal fue garantizar que la comunicación entre los distintos servicios del backend funcione correctamente, asegurando que las operaciones como creación, consulta o actualización de datos se ejecuten de manera coherente e integrada.  

---

### Campaign Bounded Context

```csharp
using System.Net;
using System.Net.Http.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc.Testing;
using NUnit.Framework;
using Moobile_Platform;
using Moobile_Platform.CampaignManagement.Interfaces.REST.Resources;

namespace Moobile_Platform.Tests.Integration.Campaign
{
    [TestFixture]
    public class CampaignIntegrationTests
    {
        private HttpClient _client = null!;
        private WebApplicationFactory<Program> _factory = null!;

        [SetUp]
        public void SetUp()
        {
            _factory = new WebApplicationFactory<Program>();
            _client = _factory.CreateClient();
        }

        [TearDown]
        public void TearDown()
        {
            _client.Dispose();
            _factory.Dispose();
        }

        // TEST 1: Crear una campaña correctamente
        [Test]
        public async Task CreateCampaign_ShouldReturnCreated_WhenDataIsValid()
        {
            var createResource = new CreateCampaignResource
            {
                Title = "Vacunación de Ganado Octubre",
                Description = "Campaña de vacunación contra fiebre aftosa",
                StartDate = DateTime.UtcNow,
                EndDate = DateTime.UtcNow.AddDays(10)
            };

            var response = await _client.PostAsJsonAsync("/api/v1/campaigns", createResource);

            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.Created));
            var created = await response.Content.ReadFromJsonAsync<CampaignResource>();
            Assert.That(created, Is.Not.Null);
            Assert.That(created!.Title, Is.EqualTo(createResource.Title));
        }

        // TEST 2: Obtener todas las campañas del usuario autenticado
        [Test]
        public async Task GetAllCampaigns_ShouldReturnOk_WithListOfCampaigns()
        {
            var response = await _client.GetAsync("/api/v1/campaigns");

            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
            var campaigns = await response.Content.ReadFromJsonAsync<List<CampaignResource>>();
            Assert.That(campaigns, Is.Not.Null);
        }

        // TEST 3: Actualizar el estado de una campaña existente
        [Test]
        public async Task UpdateCampaignStatus_ShouldReturnCreated_WhenCampaignExists()
        {
            var campaignId = 1; 
            var updateStatusResource = new UpdateCampaignStatusResource
            {
                Status = "Completed"
            };

            var response = await _client.PatchAsJsonAsync($"/api/v1/campaigns/{campaignId}/update-status", updateStatusResource);

            Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.Created));
            var updated = await response.Content.ReadFromJsonAsync<CampaignResource>();
            Assert.That(updated, Is.Not.Null);
            Assert.That(updated!.Status, Is.EqualTo("Completed"));
        }
    }
}
```

## Ranch Bounded Context

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Moobile_Platform.RanchManagement.Domain.Services;
using Moobile_Platform.RanchManagement.Interfaces.REST;
using Moobile_Platform.RanchManagement.Interfaces.REST.Resources;
using Moq;
using NUnit.Framework;

namespace Moobile_Platform.Tests.Ranch
{
    [TestFixture]
    public class RanchIntegrationTests
    {
        private BovinesController bovinesController;
        private VaccineController vaccineController;

        private Mock<IBovineCommandService> mockBovineCommandService;
        private Mock<IBovineQueryService> mockBovineQueryService;
        private Mock<IVaccineCommandService> mockVaccineCommandService;
        private Mock<IVaccineQueryService> mockVaccineQueryService;

        [SetUp]
        public void Setup()
        {
            mockBovineCommandService = new Mock<IBovineCommandService>();
            mockBovineQueryService = new Mock<IBovineQueryService>();
            mockVaccineCommandService = new Mock<IVaccineCommandService>();
            mockVaccineQueryService = new Mock<IVaccineQueryService>();

            bovinesController = new BovinesController(mockBovineCommandService.Object, mockBovineQueryService.Object);
            vaccineController = new VaccineController(mockVaccineCommandService.Object, mockVaccineQueryService.Object);

            var user = new ClaimsPrincipal(new ClaimsIdentity(new Claim[]
            {
                new Claim(ClaimTypes.Sid, "1")
            }, "mock"));

            bovinesController.ControllerContext = new ControllerContext
            {
                HttpContext = new DefaultHttpContext { User = user }
            };

            vaccineController.ControllerContext = new ControllerContext
            {
                HttpContext = new DefaultHttpContext { User = user }
            };
        }

        // 1. Crear un bovino
        [Test]
        public async Task CreateBovine_ShouldReturnCreatedBovine()
        {
            var resource = new CreateBovineResource
            {
                Name = "Bessie",
                Age = 3,
                StableId = 1
            };

            var createdBovine = new Domain.Model.Entities.Bovine
            {
                Id = 1,
                Name = resource.Name,
                Age = resource.Age,
                StableId = resource.StableId
            };

            mockBovineCommandService
                .Setup(s => s.Handle(It.IsAny<Domain.Model.Commands.CreateBovineCommand>()))
                .ReturnsAsync(createdBovine);

            var result = await bovinesController.CreateBovines(resource) as CreatedAtActionResult;
            var resultBovine = result?.Value as BovineResource;

            Assert.IsNotNull(result);
            Assert.AreEqual(201, result.StatusCode);
            Assert.IsNotNull(resultBovine);
            Assert.AreEqual("Bessie", resultBovine.Name);
        }

        // 2. Obtener bovinos por establo
        [Test]
        public async Task GetBovinesByStableId_ShouldReturnBovinesList()
        {
            int stableId = 1;
            var bovinesList = new List<Domain.Model.Entities.Bovine>
            {
                new Domain.Model.Entities.Bovine { Id = 1, Name = "Bessie", StableId = stableId },
                new Domain.Model.Entities.Bovine { Id = 2, Name = "Daisy", StableId = stableId }
            };

            mockBovineQueryService
                .Setup(s => s.Handle(It.IsAny<Domain.Model.Queries.GetBovinesByStableIdQuery>()))
                .ReturnsAsync(bovinesList);

            var result = await bovinesController.GetBovinesByStableId(stableId) as OkObjectResult;
            var bovines = result?.Value as IEnumerable<BovineResource>;

            Assert.IsNotNull(result);
            Assert.AreEqual(200, result.StatusCode);
            Assert.IsTrue(bovines.Any());
        }

        // 3. Crear y obtener vacuna para un bovino
        [Test]
        public async Task CreateVaccine_ForBovine_ShouldReturnVaccine()
        {
            int bovineId = 1;
            var vaccineResource = new CreateVaccineResource
            {
                Name = "Rabies",
                DateAdministered = DateTime.UtcNow,
                BovineId = bovineId
            };

            var createdVaccine = new Domain.Model.Entities.Vaccine
            {
                Id = 1,
                Name = vaccineResource.Name,
                BovineId = bovineId,
                DateAdministered = vaccineResource.DateAdministered
            };

            var vaccinesList = new List<Domain.Model.Entities.Vaccine> { createdVaccine };

            mockVaccineCommandService
                .Setup(s => s.Handle(It.IsAny<Domain.Model.Commands.CreateVaccineCommand>()))
                .ReturnsAsync(createdVaccine);

            mockVaccineQueryService
                .Setup(s => s.Handle(It.IsAny<Domain.Model.Queries.GetVaccinesByBovineIdQuery>()))
                .ReturnsAsync(vaccinesList);

            var createResult = await vaccineController.CreateVaccines(vaccineResource) as CreatedAtActionResult;
            var resultVaccine = createResult?.Value as VaccineResource;

            var getResult = await vaccineController.GetVaccinesByBovineId(bovineId) as OkObjectResult;
            var vaccines = getResult?.Value as IEnumerable<VaccineResource>;

            Assert.IsNotNull(createResult);
            Assert.AreEqual(201, createResult.StatusCode);
            Assert.IsNotNull(resultVaccine);
            Assert.IsTrue(vaccines.Any(v => v.Id == resultVaccine.Id));
        }
    }
}
```

## Staff Boundend Context

```csharp
using System.Net;
using System.Net.Http.Json;
using Moobile_Platform.StaffAdministration.Interfaces.REST.Resources;
using NUnit.Framework;

namespace Moobile_Platform.Tests.Integration.Staff
{
    [TestFixture]
    public class StaffControllerTests : IntegrationTestBase
    {
        // 1. Crear un nuevo personal
        [Test]
        public async Task CreateStaff_ShouldReturnCreatedStaff()
        {
            var newStaff = new CreateStaffResource
            {
                Name = "Carlos Gonzalez",
                EmployeeStatus = 1,
                CampaignId = 1,
                Email = "carlos@example.com"
            };

            var response = await HttpClient.PostAsJsonAsync("/api/v1/staff", newStaff);

            Assert.AreEqual(HttpStatusCode.Created, response.StatusCode);
            var createdStaff = await response.Content.ReadFromJsonAsync<StaffResource>();
            Assert.NotNull(createdStaff);
            Assert.AreEqual(newStaff.Name, createdStaff.Name);
        }

        // 2. Retornará una lista con todos los miembros del personal
        [Test]
        public async Task GetAllStaff_ShouldReturnListOfStaff()
        {
            var response = await HttpClient.GetAsync("/api/v1/staff");

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode);
            var staffList = await response.Content.ReadFromJsonAsync<IEnumerable<StaffResource>>();
            Assert.NotNull(staffList);
            Assert.IsNotEmpty(staffList);
        }

        // 3. Devuelve los datos de un empleado específico
        [Test]
        public async Task GetStaffById_ShouldReturnSpecificStaff()
        {
            var staffId = 1; 
            var response = await HttpClient.GetAsync($"/api/v1/staff/{staffId}");

            Assert.AreEqual(HttpStatusCode.OK, response.StatusCode);
            var staff = await response.Content.ReadFromJsonAsync<StaffResource>();
            Assert.NotNull(staff);
            Assert.AreEqual(staffId, staff.Id);
        }
    }
}
```

## Voice Boundend Context
```csharp
using System;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Moobile_Platform.VoiceCommand.Domain.Model.Commands;
using Moobile_Platform.VoiceCommand.Domain.Model.Queries;
using Moobile_Platform.VoiceCommand.Domain.Services;
using Moobile_Platform.VoiceCommand.Interfaces.REST;
using Moq;
using NUnit.Framework;

namespace Moobile_Platform.Tests.VoiceCommand.Interfaces.REST
{
    [TestFixture]
    public class VoiceCommandControllerTests
    {
        private Mock<IVoiceCommandService> _voiceCommandServiceMock = null!;
        private Mock<IVoiceParserService> _voiceParserServiceMock = null!;
        private Mock<IVoiceQueryService> _voiceQueryServiceMock = null!;
        private Mock<ILogger<VoiceCommandController>> _loggerMock = null!;
        private VoiceCommandController _controller = null!;

        [SetUp]
        public void Setup()
        {
            _voiceCommandServiceMock = new Mock<IVoiceCommandService>();
            _voiceParserServiceMock = new Mock<IVoiceParserService>();
            _voiceQueryServiceMock = new Mock<IVoiceQueryService>();
            _loggerMock = new Mock<ILogger<VoiceCommandController>>();

            _controller = new VoiceCommandController(
                _voiceCommandServiceMock.Object,
                _voiceParserServiceMock.Object,
                _voiceQueryServiceMock.Object,
                _loggerMock.Object
            );

            var user = new ClaimsPrincipal(new ClaimsIdentity(new Claim[]
            {
                new Claim(ClaimTypes.Sid, "1"),
                new Claim(ClaimTypes.Name, "TestUser")
            }, "mock"));

            _controller.ControllerContext = new ControllerContext
            {
                HttpContext = new DefaultHttpContext { User = user }
            };
        }

        // TEST 1: Procesar comando de voz
        [Test]
        public async Task ProcessVoiceCommand_ShouldReturnOk_WhenValidAudio()
        {
            var mockFile = new Mock<IFormFile>();
            mockFile.Setup(f => f.Length).Returns(1024);
            mockFile.Setup(f => f.ContentType).Returns("audio/wav");
            mockFile.Setup(f => f.FileName).Returns("voice.wav");
            mockFile.Setup(f => f.OpenReadStream()).Returns(new System.IO.MemoryStream(new byte[1024]));

            _voiceCommandServiceMock
                .Setup(s => s.Handle(It.IsAny<ProcessVoiceCommand>()))
                .ReturnsAsync(new { success = true, message = "Processed successfully" });

            var result = await _controller.ProcessVoiceCommand(mockFile.Object);

            Assert.That(result, Is.InstanceOf<OkObjectResult>());
            var okResult = result as OkObjectResult;
            Assert.That(okResult?.Value, Is.Not.Null);
        }

        // TEST 2: Analizar comando en texto
        [Test]
        public void ParseTextCommand_ShouldReturnOk_WhenTextIsValid()
        {
            var request = new ParseTextRequest("turn on the light");

            _voiceParserServiceMock.Setup(p => p.ParseCommand(It.IsAny<string>()))
                .Returns(new MockCommandResult
                {
                    IsValid = true,
                    CommandType = "LightControl",
                    Parameters = new Dictionary<string, string> { { "device", "light" } },
                    OriginalText = request.Text
                });

            var result = _controller.ParseTextCommand(request);

            Assert.That(result, Is.InstanceOf<OkObjectResult>());
            var okResult = result as OkObjectResult;
            Assert.That(okResult?.Value, Is.Not.Null);
        }

        // TEST 3: Obtener comando de voz por ID
        [Test]
        public async Task GetVoiceCommandById_ShouldReturnOk_WhenFoundAndOwnedByUser()
        {
            var voiceCommand = new VoiceEntityMock { Id = 1, UserId = 1, Text = "Play music" };

            _voiceQueryServiceMock.Setup(q => q.Handle(It.IsAny<GetVoicesByIdQuery>()))
                .ReturnsAsync(voiceCommand);

            var result = await _controller.GetVoiceCommandById(1);

            Assert.That(result, Is.InstanceOf<OkObjectResult>());
            var okResult = result as OkObjectResult;
            Assert.That(okResult?.Value, Is.Not.Null);
        }

        private class VoiceEntityMock
        {
            public int Id { get; set; }
            public int UserId { get; set; }
            public string Text { get; set; } = string.Empty;
        }

        private class MockCommandResult
        {
            public bool IsValid { get; set; }
            public string CommandType { get; set; } = string.Empty;
            public Dictionary<string, string> Parameters { get; set; } = new();
            public string OriginalText { get; set; } = string.Empty;
        }
    }
}
```

## IAM Boundend Context
```csharp
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Moq;
using NUnit.Framework;
using Moobile_Platform.IAM.Domain.Services;
using Moobile_Platform.IAM.Domain.Model.Entities;
using Moobile_Platform.IAM.Domain.Model.Commands;
using Moobile_Platform.IAM.Interfaces.REST;
using Moobile_Platform.IAM.Interfaces.REST.Resources.UserResources;
using Moobile_Platform.IAM.Interfaces.REST.Transform.TransformFromUserResources;

namespace Moobile_Platform.Tests.IAM
{
    [TestFixture]
    public class IAMIntegrationTests
    {
        private Mock<IUserCommandService> _mockUserCommandService = null!;
        private Mock<IUserQueryService> _mockUserQueryService = null!;
        private Mock<IAdminCommandService> _mockAdminCommandService = null!;
        private Mock<IAdminQueryService> _mockAdminQueryService = null!;
        private UserController _userController = null!;
        private AdminController _adminController = null!;

        [SetUp]
        public void Setup()
        {
            _mockUserCommandService = new Mock<IUserCommandService>();
            _mockUserQueryService = new Mock<IUserQueryService>();
            _mockAdminCommandService = new Mock<IAdminCommandService>();
            _mockAdminQueryService = new Mock<IAdminQueryService>();

            _userController = new UserController(_mockUserCommandService.Object, _mockUserQueryService.Object);
            _adminController = new AdminController(_mockAdminCommandService.Object, _mockAdminQueryService.Object, _mockUserQueryService.Object);
        }

        // Test 1: Verificar registro de usuario exitoso
        [Test]
        public async Task SignUp_ShouldReturnCreated_WhenUserIsRegistered()
        {
            var resource = new SignUpResource("Carlos", "carlos@example.com", "123456");
            var userEntity = new User { Id = 1, Username = "Carlos", Email = "carlos@example.com" };

            _mockUserCommandService
                .Setup(s => s.Handle(It.IsAny<SignUpCommand>()))
                .ReturnsAsync(userEntity);

            var result = await _userController.SignUp(resource);

            Assert.IsInstanceOf<CreatedAtActionResult>(result);
            var createdResult = result as CreatedAtActionResult;
            Assert.NotNull(createdResult?.Value);
        }

        // Test 2: Verificar inicio de sesión exitoso
        [Test]
        public async Task SignIn_ShouldReturnOk_WhenCredentialsAreValid()
        {
            // Arrange
            var resource = new SignInResource("carlos@example.com", null, "123456");
            var userEntity = new User { Id = 1, Username = "Carlos", Email = "carlos@example.com" };

            _mockUserCommandService
                .Setup(s => s.Handle(It.IsAny<SignInCommand>()))
                .ReturnsAsync(userEntity);

            _mockUserQueryService
                .Setup(s => s.GetUserNameByEmail(resource.Email))
                .ReturnsAsync("Carlos");

            _mockUserQueryService
                .Setup(s => s.GetEmailByUserName(It.IsAny<string>()))
                .ReturnsAsync(resource.Email);

            var result = await _userController.SignIn(resource);

            Assert.IsInstanceOf<OkObjectResult>(result.Result);
            var okResult = result.Result as OkObjectResult;
            Assert.NotNull(okResult?.Value);
        }
    }
}
```

### 6.1.3. Core Behavior-Driven Development

### 6.1.4. Core System Tests

## 6.2. Static testing & Verification

### 6.2.1. Static Code Analysis

#### 6.2.1.1. Coding standard & Code conventions

#### 6.2.1.2. Code Quality & Code Security

### 6.2.2. Reviews

## 6.3. Validation Interviews

### 6.3.1. Diseño de Entrevistas

### 6.3.2. Registro de Entrevistas

### 6.3.3. Evaluaciones según heurísticas

## 6.4. Auditoría de Experiencias de Usuario

### 6.4.1. Auditoría realizada

#### 6.4.1.1. Información del grupo auditado

#### 6.4.1.2. Cronograma de auditoría realizada

#### 6.4.1.3. Contenido de auditoría realizada

### 6.4.2. Auditoría recibida

#### 6.4.2.1. Información del grupo auditor

#### 6.4.2.2. Cronograma de auditoría recibida

#### 6.4.2.3. Contenido de auditoría recibida

#### 6.4.2.4. Resumen de modificaciones para subsanar hallazgos

# **Capítulo VII: DevOps Practices**

## 7.1. Continuous Integration

### 7.1.1. Tools and Practices

### 7.1.2. Build & Test Suite Pipeline Components

## 7.2. Continuous Delivery

### 7.2.1. Tools and Practices

### 7.2.2. Stages Deployment Pipeline Components

## 7.3. Continuous deployment

### 7.3.1. Tools and Practices

### 7.3.2. Production Deployment Pipeline Components

## 7.4. Continuous Monitoring

### 7.4.1. Tools and Practices

### 7.4.2. Monitoring Pipeline Components

### 7.4.3. Alerting Pipeline Components

### 7.4.4. Notification Pipeline Components

# **Part III: Experiment-Driven Lifecycle**

# **Capítulo VIII: Experiment-Driven Development**

## 8.1. Experiment Planning

### 8.1.1. As-Is Summary

### 8.1.2. Raw Material: Assumptions, Knowledge Gaps, Ideas, Claims

### 8.1.3. Experiment-Ready Questions

### 8.1.4. Question Backlog

### 8.1.5. Experiment Cards

## 8.2. Experiment Design

### 8.2.1. Hypotheses

### 8.2.2. Domain Business Metrics

### 8.2.3. Measures

### 8.2.4. Conditions

### 8.2.5. Scale Calculations and Decisions

### 8.2.6. Methods Selection

### 8.2.7. Data Analytics: Goals, KPIs and Metrics Selection

### 8.2.8. Web and Mobile Tracking Plan

## 8.3. Experimentation

### 8.3.1. To-Be User Stories

### 8.3.2. To-Be Product Backlog

### 8.3.3. Pipeline-supported, Experiment-Driven To-Be Software Platform Lifecycle

#### 8.3.3.1. To-Be Sprint Backlogs

#### 8.3.3.2. Implemented To-Be Landing Page Evidence

#### 8.3.3.3. Implemented To-Be Frontend-Web Application Evidence

#### 8.3.3.4. Implemented To-Be Native-Mobile Application Evidence

#### 8.3.3.5. Implemented To-Be RESTful API and/or Serverless Backend Evidence

#### 8.3.3.6. Team Collaboration Insights

### 8.3.4. To-Be Validation Interviews

#### 8.3.4.1. Diseño de Entrevistas

#### 8.3.4.2. Registro de Entrevistas

## 8.4. Experiment Aftermath & Analysis

### 8.4.1. Analysis and Interpretation of Results

### 8.4.2. Re-scored and Re-prioritized Question Backlog

## 8.5. Continuous Learning

### 8.5.1. Shareback Session Artifacts: Learning Workflow

## 8.6. To-Be Software Platform Pre-launch

### 8.6.1. About-the-Product Intro Video

----

# Conclusiones

## Conclusiones Y Recomendaciones

## Video App Validation

## Video About-the-Team

----

# Bibliografía

----

# Anexos
